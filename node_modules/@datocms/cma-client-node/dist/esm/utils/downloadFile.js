var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { dir } from 'tmp-promise';
import got, { CancelError } from 'got';
import { promises } from 'fs';
import { basename, join } from 'path';
import { URL } from 'url';
import { CanceledPromiseError, makeCancelablePromise, } from '@datocms/rest-client-utils';
export function downloadFile(url, { onProgress } = {}) {
    let isCancelled = false;
    let requestPromise;
    return makeCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {
        if (isCancelled) {
            throw new CanceledPromiseError();
        }
        const { path: tmpDir, cleanup: deleteTmpDir } = yield dir({
            unsafeCleanup: true,
        });
        if (isCancelled) {
            yield deleteTmpDir();
            throw new CanceledPromiseError();
        }
        try {
            requestPromise = got(url, { responseType: 'buffer', maxRedirects: 10 });
            if (onProgress) {
                requestPromise.on('downloadProgress', ({ percent }) => {
                    if (isCancelled) {
                        return;
                    }
                    onProgress({
                        type: 'DOWNLOADING_FILE',
                        payload: { url, progress: Math.round(percent * 100) },
                    });
                });
            }
            let response;
            try {
                response = yield requestPromise;
            }
            catch (e) {
                if (e instanceof CancelError) {
                    throw new CanceledPromiseError();
                }
                else {
                    throw e;
                }
            }
            if (isCancelled) {
                throw new CanceledPromiseError();
            }
            const filePath = join(tmpDir, basename(new URL(url).pathname));
            yield promises.writeFile(filePath, response.body);
            return {
                filePath,
                deleteFile: deleteTmpDir,
            };
        }
        catch (e) {
            deleteTmpDir();
            throw e;
        }
    }), () => {
        isCancelled = true;
        if (requestPromise) {
            requestPromise.cancel();
        }
    });
}
//# sourceMappingURL=downloadFile.js.map