/**
 * This file was automatically generated by hyperschema-to-ts: DO NOT MODIFY IT BY HAND.
 */
/**
 * ID of role
 *
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type RoleIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type RoleType = 'role';
/**
 * ID of item type
 *
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type ItemTypeIdentity = string;
/**
 * ID of workflow
 *
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type WorkflowIdentity = string;
/**
 * ID of environment. Can only contain lowercase letters, numbers and dashes
 *
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type EnvironmentIdentity = string;
/**
 * ID of build_trigger
 *
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type BuildTriggerIdentity = string;
/**
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type RoleInstancesTargetSchema = Role[];
/**
 * ID of collaborator
 *
 * This interface was referenced by `User`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `User`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type UserIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `User`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type UserType = 'user';
/**
 * This interface was referenced by `User`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type UserInstancesTargetSchema = User[];
/**
 * This interface was referenced by `User`'s JSON-Schema
 * via the `self.hrefSchema` link.
 */
export declare type UserSelfHrefSchema = {
    /**
     * Comma-separated list of [relationship paths](https://jsonapi.org/format/#fetching-includes). A relationship path is a dot-separated list of relationship names. Allowed relationship paths: `role`.
     */
    include?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `User`'s JSON-Schema
 * via the `me.targetSchema` link.
 */
export declare type UserMeTargetSchema = User | SsoUser | AccessToken | Account;
/**
 * ID of user
 *
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SsoUserIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SsoUserType = 'sso_user';
/**
 * JSON API type field
 *
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SsoGroupType = 'sso_group';
/**
 * ID of group
 *
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SsoGroupIdentity = string;
/**
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type SsoUserInstancesTargetSchema = SsoUser[];
/**
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `copy_users.targetSchema` link.
 */
export declare type SsoUserCopyUsersTargetSchema = SsoUser[];
/**
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `destroy.hrefSchema` link.
 */
export declare type SsoUserDestroyHrefSchema = {
    /**
     * New owner for resources previously owned by the deleted SSO user. This argument specifies the new owner type.
     */
    destination_user_type?: 'account' | 'user' | 'access_token' | 'sso_user';
    /**
     * New owner for resources previously owned by the deleted SSO user. This argument specifies the new owner ID.
     */
    destination_user_id?: string;
    [k: string]: unknown;
};
/**
 * ID of access_token
 *
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type AccessTokenIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type AccessTokenType = 'access_token';
/**
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type AccessTokenInstancesTargetSchema = AccessToken[];
/**
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `destroy.hrefSchema` link.
 */
export declare type AccessTokenDestroyHrefSchema = {
    /**
     * New owner for resources previously owned by the deleted access token. This argument specifies the new owner type.
     */
    destination_user_type?: 'account' | 'user' | 'access_token' | 'sso_user';
    /**
     * New owner for resources previously owned by the deleted access token. This argument specifies the new owner ID.
     */
    destination_user_id?: string;
    [k: string]: unknown;
};
/**
 * ID of account
 *
 * This interface was referenced by `Account`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Account`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type AccountIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Account`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type AccountType = 'account';
/**
 * This interface was referenced by `User`'s JSON-Schema
 * via the `me.hrefSchema` link.
 */
export declare type UserMeHrefSchema = {
    /**
     * Comma-separated list of [relationship paths](https://jsonapi.org/format/#fetching-includes). A relationship path is a dot-separated list of relationship names. Allowed relationship paths: `role`.
     */
    include?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `User`'s JSON-Schema
 * via the `destroy.hrefSchema` link.
 */
export declare type UserDestroyHrefSchema = {
    /**
     * New owner for resources previously owned by the deleted user. This argument specifies the new owner type.
     */
    destination_user_type?: 'account' | 'user' | 'access_token' | 'sso_user';
    /**
     * New owner for resources previously owned by the deleted user. This argument specifies the new owner ID.
     */
    destination_user_id?: string;
    [k: string]: unknown;
};
/**
 * ULID of event (https://github.com/ulid/spec)
 *
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type AuditLogEventIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type AuditLogEventType = 'audit_log_event';
/**
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `query.targetSchema` link.
 */
export declare type AuditLogEventQueryTargetSchema = AuditLogEvent[];
/**
 * ID of plan
 *
 * This interface was referenced by `SitePlan`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SitePlan`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SitePlanIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `SitePlan`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SitePlanType = 'site_plan';
/**
 * ID of menu item
 *
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type MenuItemIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type MenuItemType = 'menu_item';
/**
 * JSON API type field
 *
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type ItemTypeType = 'item_type';
/**
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type MenuItemInstancesTargetSchema = MenuItem[];
/**
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type MenuItemInstancesHrefSchema = {
    filter?: {
        /**
         * IDs to fetch, comma separated
         */
        ids: string;
    };
};
/**
 * JSON API type field
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type ItemType1 = 'item';
/**
 * ID of record
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type ItemIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type FieldType = 'field';
/**
 * ID of field
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type FieldIdentity = string;
/**
 * JSON API type fieldset
 *
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type FieldsetType = 'fieldset';
/**
 * ID of fieldset
 *
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type FieldsetIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type WorkflowType = 'workflow';
/**
 * ID of job
 *
 * This interface was referenced by `Job`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Job`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type JobIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Job`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type JobType = 'job';
/**
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type ItemTypeInstancesTargetSchema = ItemType[];
/**
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type FieldInstancesTargetSchema = Field[];
/**
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `referencing.targetSchema` link.
 */
export declare type FieldReferencingTargetSchema = Field[];
/**
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `related.targetSchema` link.
 */
export declare type FieldRelatedTargetSchema = Field[];
/**
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type FieldsetInstancesTargetSchema = Fieldset[];
/**
 * JSON web token for the session
 *
 * This interface was referenced by `Session`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Session`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SessionIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Session`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SessionType = 'session';
/**
 * ID of plugin
 *
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type PluginIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type PluginType = 'plugin';
/**
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type PluginInstancesTargetSchema = Plugin[];
/**
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `fields.targetSchema` link.
 */
export declare type PluginFieldsTargetSchema = Field[];
/**
 * ID of job result
 *
 * This interface was referenced by `JobResult`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `JobResult`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type JobResultIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `JobResult`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type JobResultType = 'job_result';
/**
 * ID of limit
 *
 * This interface was referenced by `SubscriptionLimit`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SubscriptionLimit`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SubscriptionLimitIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `SubscriptionLimit`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SubscriptionLimitType = 'subscription_limit';
/**
 * This interface was referenced by `SubscriptionLimit`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type SubscriptionLimitInstancesTargetSchema = SubscriptionLimit[];
/**
 * ID of feature
 *
 * This interface was referenced by `SubscriptionFeature`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SubscriptionFeature`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SubscriptionFeatureIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `SubscriptionFeature`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SubscriptionFeatureType = 'subscription_feature';
/**
 * This interface was referenced by `SubscriptionFeature`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type SubscriptionFeatureInstancesTargetSchema = SubscriptionFeature[];
/**
 * ID of menu item
 *
 * This interface was referenced by `BuildEvent`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `BuildEvent`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type BuildEventIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `BuildEvent`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type BuildEventType = 'build_event';
/**
 * JSON API type field
 *
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type BuildTriggerType = 'build_trigger';
/**
 * This interface was referenced by `BuildEvent`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type BuildEventInstancesTargetSchema = BuildEvent[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type ItemInstancesTargetSchema = Item[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type ItemInstancesHrefSchema = {
    /**
     * For Modular Content fields and Structured Text fields. If set, returns full payload for nested blocks instead of IDs
     */
    nested?: string;
    /**
     * Attributes to filter records
     */
    filter?: {
        /**
         * Record (or block record) IDs to fetch, comma separated. If you use this filter, you _must not_ use `filter[type]` or `filter[fields]`
         */
        ids?: string;
        /**
         * Model ID or `api_key` to filter. If you use this filter, you _must not_ use `filter[ids]`. Comma separated values are accepted, but you _must not_ use `filter[fields]` in this case
         */
        type?: string;
        /**
         * Textual query to match. You _must not_ use `filter[ids]`. If `locale` is defined, search within that locale. Otherwise environment's main locale will be used.
         */
        query?: string;
        /**
         * Same as [GraphQL API records filters](/docs/content-delivery-api/filtering-records). Use snake_case for fields names. If `locale` is defined, search within that locale. Otherwise environment's main locale will be used.
         */
        fields?: {
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * When `filter[query]` or `field[fields]` is defined, filter by this locale. Default: environment's main locale
     */
    locale?: string;
    /**
     * Attributes to manage results pagination
     */
    page?: {
        /**
         * Index of first record to fetch (defaults to 0)
         */
        offset?: number;
        /**
         * Number of records to fetch (defaults to 30, maximum is 500)
         */
        limit?: number;
        [k: string]: unknown;
    };
    /**
     * Fields used to order results. You _must_ specify also `filter[type]` with one element only to be able use this option. Format: `<field_name>_<DIRECTION(ASC|DESC)>`. You can pass multiple comma separated rules
     */
    order_by?: string;
    /**
     * Whether you want the currently published versions (`published`, default) of your records, or the latest available (`current`)
     */
    version?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `references.targetSchema` link.
 */
export declare type ItemReferencesTargetSchema = Item[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `references.hrefSchema` link.
 */
export declare type ItemReferencesHrefSchema = {
    /**
     * For Modular Content fields and Structured Text fields, return full payload for nested blocks instead of IDs
     */
    nested?: 'true';
    /**
     * Retrieve only the selected type of version that is linked to the record; current, published or both
     */
    version?: null | ('current' | 'published' | 'published-or-current');
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `self.hrefSchema` link.
 */
export declare type ItemSelfHrefSchema = {
    /**
     * For Modular Content fields and Structured Text fields. If set, returns full payload for nested blocks instead of IDs
     */
    nested?: string;
    /**
     * Whether you want the currently published versions (`published`, default) of your records, or the latest available (`current`)
     */
    version?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_destroy.jobSchema` link.
 */
export declare type ItemBatchDestroyJobSchema = unknown[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_destroy.hrefSchema` link.
 */
export declare type ItemBatchDestroyHrefSchema = {
    /**
     * IDs of records to delete, comma separated
     */
    'filter[ids]': string;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_publish.jobSchema` link.
 */
export declare type ItemBatchPublishJobSchema = unknown[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_publish.hrefSchema` link.
 */
export declare type ItemBatchPublishHrefSchema = {
    /**
     * IDs of records to publish, comma separated
     */
    'filter[ids]': string;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_unpublish.jobSchema` link.
 */
export declare type ItemBatchUnpublishJobSchema = unknown[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_unpublish.hrefSchema` link.
 */
export declare type ItemBatchUnpublishHrefSchema = {
    /**
     * IDs of records to unpublish, comma separated
     */
    'filter[ids]': string;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `publish.hrefSchema` link.
 */
export declare type ItemPublishHrefSchema = {
    /**
     * If the record references other draft records, force a recursive publication
     */
    recursive?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `unpublish.hrefSchema` link.
 */
export declare type ItemUnpublishHrefSchema = {
    /**
     * If the record is referenced by other published records, unpublish them recursively
     */
    recursive?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_publish.jobSchema` link.
 */
export declare type ItemBulkPublishJobSchema = unknown[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_unpublish.jobSchema` link.
 */
export declare type ItemBulkUnpublishJobSchema = unknown[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_destroy.jobSchema` link.
 */
export declare type ItemBulkDestroyJobSchema = unknown[];
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_move_to_stage.jobSchema` link.
 */
export declare type ItemBulkMoveToStageJobSchema = unknown[];
/**
 * ID of record version
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type ItemVersionIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type ItemVersionType = 'item_version';
/**
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `restore.jobSchema` link.
 */
export declare type ItemVersionRestoreJobSchema = [Item, ItemVersion];
/**
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type ItemVersionInstancesTargetSchema = ItemVersion[];
/**
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type ItemVersionInstancesHrefSchema = {
    /**
     * For Modular Content fields and Structured Text fields. If set, returns full payload for nested blocks instead of IDs
     */
    nested?: string;
    /**
     * Attributes to manage results pagination
     */
    page?: {
        /**
         * Index of first element to fetch (defaults to 0)
         */
        offset?: number;
        /**
         * Number of elements to fetch  (defaults to 15, maximum is 50)
         */
        limit?: number;
        [k: string]: unknown;
    };
    [k: string]: unknown;
};
/**
 * ID of upload
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type UploadIdentity = string;
/**
 * JSON API type upload
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type UploadType = 'upload';
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type UploadInstancesTargetSchema = Upload[];
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type UploadInstancesHrefSchema = {
    /**
     * Attributes to filter uploads
     */
    filter?: {
        /**
         * IDs to fetch, comma separated
         */
        ids?: string;
        /**
         * Textual query to match. If `locale` is defined, search within that locale. Otherwise environment's main locale will be used.
         */
        query?: string;
        /**
         * Same as [GraphQL API uploads filters](/docs/content-delivery-api/filtering-uploads). Use snake_case for fields names. If `locale` is defined, search within that locale. Otherwise environment's main locale will be used.
         */
        fields?: {
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * When `filter[query]` or `field[fields]` is defined, filter by this locale. Default: environment's main locale
     */
    locale?: string;
    /**
     * Fields used to order results. Format: `<field_name>_<DIRECTION(ASC|DESC)>`. You can pass multiple comma separated rules.
     */
    order_by?: string;
    /**
     * Attributes to manage results pagination
     */
    page?: {
        /**
         * Index of first upload to fetch (defaults to 0)
         */
        offset?: number;
        /**
         * Number of uplads to fetch (defaults to 30, maximum is 500)
         */
        limit?: number;
        [k: string]: unknown;
    };
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `batch_add_tags.jobSchema` link.
 */
export declare type UploadBatchAddTagsJobSchema = unknown[];
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `batch_add_tags.hrefSchema` link.
 */
export declare type UploadBatchAddTagsHrefSchema = {
    /**
     * IDs to tag, comma separated
     */
    'filter[ids]'?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `batch_destroy.jobSchema` link.
 */
export declare type UploadBatchDestroyJobSchema = unknown[];
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `batch_destroy.hrefSchema` link.
 */
export declare type UploadBatchDestroyHrefSchema = {
    /**
     * IDs to destroy, comma separated
     */
    'filter[ids]'?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `references.targetSchema` link.
 */
export declare type UploadReferencesTargetSchema = Item[];
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `references.hrefSchema` link.
 */
export declare type UploadReferencesHrefSchema = {
    /**
     * For Modular Content fields and Structured Text fields, return full payload for nested blocks instead of IDs
     */
    nested?: string;
    /**
     * Retrieve only the selected type of version that is linked to the upload; current, published or both
     */
    version?: null | ('current' | 'published' | 'published-or-current');
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `bulk_tag.jobSchema` link.
 */
export declare type UploadBulkTagJobSchema = unknown[];
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `bulk_destroy.jobSchema` link.
 */
export declare type UploadBulkDestroyJobSchema = unknown[];
/**
 * The S3 path where the file will be stored
 *
 * This interface was referenced by `UploadRequest`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `UploadRequest`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type UploadRequestIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `UploadRequest`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type UploadRequestType = 'upload_request';
/**
 * ID of scheduled_publication
 *
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type ScheduledPublicationIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type ScheduledPublicationType = 'scheduled_publication';
/**
 * ID of scheduled_unpublishing
 *
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type ScheduledUnpublishingIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type ScheduledUnpublishingType = 'scheduled_unpublishing';
/**
 * ID of result
 *
 * This interface was referenced by `SearchResult`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SearchResult`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SearchResultIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `SearchResult`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SearchResultType = 'search_result';
/**
 * This interface was referenced by `SearchResult`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type SearchResultInstancesTargetSchema = SearchResult[];
/**
 * This interface was referenced by `SearchResult`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type SearchResultInstancesHrefSchema = {
    /**
     * Attributes to manage results pagination
     */
    page?: {
        /**
         * Index of first element to fetch (defaults to 0)
         */
        offset?: number;
        /**
         * Number of elements to fetch (defaults to 20, maximum is 100)
         */
        limit?: number;
        [k: string]: unknown;
    };
    /**
     * Attributes to filter search results
     */
    filter: {
        /**
         * Text to search
         */
        query: string;
        /**
         * The build trigger ID on which the search will be performed. Required if more than one build trigger is present in a project
         */
        build_trigger_id?: string;
        /**
         * Restrict the search on pages in a specific locale
         */
        locale?: string;
        [k: string]: unknown;
    };
    [k: string]: unknown;
};
/**
 * JSON API type field
 *
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type EnvironmentType = 'environment';
/**
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `fork.targetSchema` link.
 */
export declare type EnvironmentForkTargetSchema = Job | Environment;
/**
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type EnvironmentInstancesTargetSchema = Environment[];
/**
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `destroy.targetSchema` link.
 */
export declare type EnvironmentDestroyTargetSchema = Job | Environment;
/**
 * ID of maintenance_mode
 *
 * This interface was referenced by `MaintenanceMode`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `MaintenanceMode`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type MaintenanceModeIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `MaintenanceMode`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type MaintenanceModeType = 'maintenance_mode';
/**
 * This interface was referenced by `MaintenanceMode`'s JSON-Schema
 * via the `activate.hrefSchema` link.
 */
export declare type MaintenanceModeActivateHrefSchema = {
    /**
     * Force the activation, even if there are collaborators editing some records.
     */
    force?: boolean;
    [k: string]: unknown;
};
/**
 * ID of webhook
 *
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type WebhookIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type WebhookType = 'webhook';
/**
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type WebhookInstancesTargetSchema = Webhook[];
/**
 * ID of webhook call
 *
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type WebhookCallIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type WebhookCallType = 'webhook_call';
/**
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type WebhookCallInstancesTargetSchema = WebhookCall[];
/**
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type WebhookCallInstancesHrefSchema = {
    /**
     * Params to manage results pagination
     */
    page?: {
        /**
         * Index of first element to fetch (defaults to 0)
         */
        offset?: number;
        /**
         * Number of elements to fetch (defaults to 30, maximum is 500)
         */
        limit?: number;
        [k: string]: unknown;
    };
    [k: string]: unknown;
};
/**
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type BuildTriggerInstancesTargetSchema = BuildTrigger[];
/**
 * ID of filter
 *
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type ItemTypeFilterIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type ItemTypeFilterType = 'item_type_filter';
/**
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type ItemTypeFilterInstancesTargetSchema = ItemTypeFilter[];
/**
 * ID of filter
 *
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type UploadFilterIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type UploadFilterType = 'upload_filter';
/**
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type UploadFilterInstancesTargetSchema = UploadFilter[];
/**
 * ID of invitation
 *
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SiteInvitationIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SiteInvitationType = 'site_invitation';
/**
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type SiteInvitationInstancesTargetSchema = SiteInvitation[];
/**
 * UUID of presence
 *
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type EditingSessionIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type EditingSessionType = 'editing_session';
/**
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type EditingSessionInstancesTargetSchema = EditingSession[];
/**
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type EditingSessionUpdateSchema = {
    /**
     * JSON API type
     */
    type?: 'editing_session_enter_item';
    item: ItemData;
    [k: string]: unknown;
} | {
    /**
     * JSON API type
     */
    type?: 'editing_session_take_over_item';
    item: ItemData;
    [k: string]: unknown;
} | {
    /**
     * JSON API type
     */
    type?: 'editing_session_lock_item';
    item: ItemData;
    [k: string]: unknown;
} | {
    /**
     * JSON API type
     */
    type?: 'editing_session_unlock_item';
    [k: string]: unknown;
};
/**
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type SsoGroupInstancesTargetSchema = SsoGroup[];
/**
 * ID
 *
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SsoSettingsIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SsoSettingsType = 'sso_settings';
/**
 * ID
 *
 * This interface was referenced by `WhiteLabelSettings`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `WhiteLabelSettings`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type WhiteLabelSettingsIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `WhiteLabelSettings`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type WhiteLabelSettingsType = 'white_label_settings';
/**
 * ID of site
 *
 * This interface was referenced by `PublicInfo`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `PublicInfo`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type PublicInfoIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `PublicInfo`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type PublicInfoType = 'public_info';
/**
 * ID of site
 *
 * This interface was referenced by `DailyUsage`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `DailyUsage`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type DailyUsageIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `DailyUsage`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type DailyUsageType = 'daily_usage';
/**
 * This interface was referenced by `DailyUsage`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type DailyUsageInstancesTargetSchema = DailyUsage[];
/**
 * Name of the counter
 *
 * This interface was referenced by `UsageCounter`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `UsageCounter`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type UsageCounterIdentity = 'assets_path_bytes' | 'assets_referrer_bytes' | 'assets_ip_bytes' | 'assets_full_path_bytes' | 'assets_path_requests' | 'assets_full_path_requests' | 'cda_access_token_id_bytes' | 'cda_access_token_id_requests' | 'cda_referrer_bytes' | 'cda_referrer_requests' | 'cda_ip_bytes' | 'cda_ip_requests' | 'cma_endpoint_bytes' | 'cma_endpoint_requests' | 'cma_user_bytes' | 'cma_user_requests' | 'cma_ip_bytes' | 'cma_ip_requests' | 'video_path_seconds';
/**
 * JSON API type field
 *
 * This interface was referenced by `UsageCounter`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type UsageCounterType = 'usage_counter';
/**
 * This interface was referenced by `UsageCounter`'s JSON-Schema
 * via the `self.hrefSchema` link.
 */
export declare type UsageCounterSelfHrefSchema = {
    /**
     * The time period upon which counters will be returned
     */
    period?: 'today' | 'current_month' | 'last_month';
};
/**
 * ID of upload tag
 *
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type UploadTagIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type UploadTagType = 'upload_tag';
/**
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type UploadTagInstancesTargetSchema = UploadTag[];
/**
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type UploadTagInstancesHrefSchema = {
    /**
     * Attributes to filter tags
     */
    filter?: {
        /**
         * Textual query to match.
         */
        query?: string;
        [k: string]: unknown;
    };
    /**
     * Attributes to manage results pagination
     */
    page?: {
        /**
         * Index of first tag to fetch (defaults to 0)
         */
        offset?: number;
        /**
         * Number of tags to fetch (defaults to 50, maximum is 500)
         */
        limit?: number;
        [k: string]: unknown;
    };
    [k: string]: unknown;
};
/**
 * ID of upload tag
 *
 * This interface was referenced by `UploadSmartTag`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `UploadSmartTag`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type UploadSmartTagIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `UploadSmartTag`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type UploadSmartTagType = 'upload_smart_tag';
/**
 * This interface was referenced by `UploadSmartTag`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type UploadSmartTagInstancesTargetSchema = UploadSmartTag[];
/**
 * This interface was referenced by `UploadSmartTag`'s JSON-Schema
 * via the `instances.hrefSchema` link.
 */
export declare type UploadSmartTagInstancesHrefSchema = {
    /**
     * Attributes to filter tags
     */
    filter?: {
        /**
         * Textual query to match.
         */
        query?: string;
        [k: string]: unknown;
    };
    /**
     * Attributes to manage results pagination
     */
    page?: {
        /**
         * Index of first tag to fetch (defaults to 0)
         */
        offset?: number;
        /**
         * Number of tags to fetch (defaults to 50, maximum is 500)
         */
        limit?: number;
        [k: string]: unknown;
    };
    [k: string]: unknown;
};
/**
 * ID of site
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `definition` "identity".
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `definition` "id".
 */
export declare type SiteIdentity = string;
/**
 * JSON API type field
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `definition` "type".
 */
export declare type SiteType = 'site';
/**
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `self.hrefSchema` link.
 */
export declare type SiteSelfHrefSchema = {
    /**
     * Comma-separated list of [relationship paths](https://jsonapi.org/format/#fetching-includes). A relationship path is a dot-separated list of relationship names. Allowed relationship paths: `item_types`, `item_types.fields`, `item_types.fieldsets`, `item_types.singleton_item`, `account`.
     */
    include?: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `instances.targetSchema` link.
 */
export declare type WorkflowInstancesTargetSchema = Workflow[];
export declare type DatoApi = {
    role?: Role;
    user?: User;
    sso_user?: SsoUser;
    audit_log_event?: AuditLogEvent;
    account?: Account;
    site_plan?: SitePlan;
    menu_item?: MenuItem;
    item_type?: ItemType;
    field?: Field;
    fieldset?: Fieldset;
    job?: Job;
    session?: Session;
    access_token?: AccessToken;
    plugin?: Plugin;
    job_result?: JobResult;
    subscription_limit?: SubscriptionLimit;
    subscription_feature?: SubscriptionFeature;
    build_event?: BuildEvent;
    item?: Item;
    item_version?: ItemVersion;
    upload?: Upload;
    upload_request?: UploadRequest;
    scheduled_publication?: ScheduledPublication;
    scheduled_unpublishing?: ScheduledUnpublishing;
    search_result?: SearchResult;
    environment?: Environment;
    maintenance_mode?: MaintenanceMode;
    webhook?: Webhook;
    webhook_call?: WebhookCall;
    build_trigger?: BuildTrigger;
    item_type_filter?: ItemTypeFilter;
    upload_filter?: UploadFilter;
    site_invitation?: SiteInvitation;
    editing_session?: EditingSession;
    sso_group?: SsoGroup;
    sso_settings?: SsoSettings;
    white_label_settings?: WhiteLabelSettings;
    public_info?: PublicInfo;
    daily_usage?: DailyUsage;
    usage_counter?: UsageCounter;
    upload_tag?: UploadTag;
    upload_smart_tag?: UploadSmartTag;
    site?: Site;
    workflow?: Workflow;
    [k: string]: unknown;
};
/**
 * A Role represents a specific set of actions an editor (or an API token) can perform on your administrative area.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "role".
 */
export declare type Role = {
    id: RoleIdentity;
    type: RoleType;
    /**
     * The name of the role
     */
    name: string;
    /**
     * Can edit favicon, global SEO settings and no-index policy
     */
    can_edit_favicon: boolean;
    /**
     * Can change project name and 2FA settings
     */
    can_edit_site: boolean;
    /**
     * Can create/edit models and plugins
     */
    can_edit_schema: boolean;
    /**
     * Can customize content navigation bar
     */
    can_manage_menu: boolean;
    /**
     * Can change locales, timezone and UI theme
     */
    can_edit_environment: boolean;
    /**
     * Can promote environments to primary and manage maintenance mode
     */
    can_promote_environments: boolean;
    /**
     * Specifies the environments the user can access
     */
    environments_access: 'all' | 'primary_only' | 'sandbox_only';
    /**
     * Can create/edit roles and invite/remove collaborators
     */
    can_manage_users: boolean;
    /**
     * Can create/edit shared filters (both for models and the media area)
     */
    can_manage_shared_filters?: boolean;
    /**
     * Can create/edit Build triggers
     */
    can_manage_build_triggers: boolean;
    /**
     * Can create/edit webhooks
     */
    can_manage_webhooks: boolean;
    /**
     * Can create/delete sandbox environments and promote them to primary environment
     */
    can_manage_environments: boolean;
    /**
     * Can manage Single Sign-On settings
     */
    can_manage_sso: boolean;
    /**
     * Can access Audit Log
     */
    can_access_audit_log: boolean;
    /**
     * Can create/edit workflows
     */
    can_manage_workflows: boolean;
    /**
     * Can manage API tokens
     */
    can_manage_access_tokens: boolean;
    /**
     * Can perform Site Search API calls
     */
    can_perform_site_search: boolean;
    /**
     * Can access the build events log
     */
    can_access_build_events_log: boolean;
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_item_type_permissions: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_item_type_permissions: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_upload_permissions: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_upload_permissions: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed build triggers for a role
     */
    positive_build_trigger_permissions: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
    /**
     * Prohibited build triggers for a role
     */
    negative_build_trigger_permissions: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
    inherits_permissions_from: RoleData[];
    meta: RoleMeta;
};
export declare type RoleCreateTargetSchema = Role;
export declare type RoleUpdateTargetSchema = Role;
export declare type RoleSelfTargetSchema = Role;
export declare type RoleDestroyTargetSchema = Role;
/**
 * JSON API data
 *
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type RoleData = {
    type: RoleType;
    id: RoleIdentity;
};
/**
 * Meta information regarding the record
 *
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type RoleMeta = {
    /**
     * The final set of permissions considering also inherited roles
     */
    final_permissions: {
        /**
         * Can edit favicon, global SEO settings and no-index policy
         */
        can_edit_favicon: boolean;
        /**
         * Can change project name and 2FA settings
         */
        can_edit_site: boolean;
        /**
         * Can create/edit models and plugins
         */
        can_edit_schema: boolean;
        /**
         * Can customize content navigation bar
         */
        can_manage_menu: boolean;
        /**
         * Can change locales, timezone and UI theme
         */
        can_edit_environment: boolean;
        /**
         * Can promote environments to primary and manage maintenance mode
         */
        can_promote_environments: boolean;
        /**
         * Specifies the environments the user can access
         */
        environments_access: 'all' | 'primary_only' | 'sandbox_only';
        /**
         * Can create/edit roles and invite/remove collaborators
         */
        can_manage_users: boolean;
        /**
         * Can create/edit shared filters (both for models and the media area)
         */
        can_manage_shared_filters?: boolean;
        /**
         * Can create/edit Build triggers
         */
        can_manage_build_triggers: boolean;
        /**
         * Can create/edit webhooks
         */
        can_manage_webhooks: boolean;
        /**
         * Can create/delete sandbox environments and promote them to primary environment
         */
        can_manage_environments: boolean;
        /**
         * Can manage Single Sign-On settings
         */
        can_manage_sso: boolean;
        /**
         * Can access Audit Log
         */
        can_access_audit_log: boolean;
        /**
         * Can create/edit workflows
         */
        can_manage_workflows: boolean;
        /**
         * Can manage API tokens
         */
        can_manage_access_tokens: boolean;
        /**
         * Can perform Site Search API calls
         */
        can_perform_site_search: boolean;
        /**
         * Can access the build events log
         */
        can_access_build_events_log: boolean;
        /**
         * Allowed actions on a model (or all) for a role
         */
        positive_item_type_permissions: {
            item_type?: ItemTypeIdentity | null;
            workflow?: WorkflowIdentity | null;
            on_stage?: null | string;
            to_stage?: null | string;
            environment: EnvironmentIdentity;
            /**
             * Permitted action
             */
            action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
            /**
             * Permitted creator
             */
            on_creator?: 'anyone' | 'self' | 'role' | null;
            /**
             * Permitted content scope
             */
            localization_scope?: 'all' | 'localized' | 'not_localized' | null;
            /**
             * Permitted localized content in this locale. Required when `localization_scope` is `localized`
             */
            locale?: string | null;
        }[];
        /**
         * Prohibited actions on a model (or all) for a role
         */
        negative_item_type_permissions: {
            item_type?: ItemTypeIdentity | null;
            workflow?: WorkflowIdentity | null;
            on_stage?: null | string;
            to_stage?: null | string;
            environment: EnvironmentIdentity;
            /**
             * Permitted action
             */
            action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
            /**
             * Permitted creator
             */
            on_creator?: 'anyone' | 'self' | 'role' | null;
            /**
             * Permitted content scope
             */
            localization_scope?: 'all' | 'localized' | 'not_localized' | null;
            /**
             * Permitted localized content in this locale. Required when `localization_scope` is `localized`
             */
            locale?: string | null;
        }[];
        /**
         * Allowed actions on a model (or all) for a role
         */
        positive_upload_permissions: {
            environment: EnvironmentIdentity;
            /**
             * Permitted action
             */
            action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
            /**
             * Permitted creator
             */
            on_creator?: 'anyone' | 'self' | 'role' | null;
            /**
             * Permitted content scope
             */
            localization_scope?: 'all' | 'localized' | 'not_localized' | null;
            /**
             * Permitted localized content in this locale. Required when `localization_scope` is `localized`
             */
            locale?: string | null;
        }[];
        /**
         * Prohibited actions on a model (or all) for a role
         */
        negative_upload_permissions: {
            environment: EnvironmentIdentity;
            /**
             * Permitted action
             */
            action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
            /**
             * Permitted creator
             */
            on_creator?: 'anyone' | 'self' | 'role' | null;
            /**
             * Permitted content scope
             */
            localization_scope?: 'all' | 'localized' | 'not_localized' | null;
            /**
             * Permitted localized content in this locale. Required when `localization_scope` is `localized`
             */
            locale?: string | null;
        }[];
        /**
         * Allowed build triggers for a role
         */
        positive_build_trigger_permissions: {
            build_trigger?: BuildTriggerIdentity | null;
        }[];
        /**
         * Prohibited build triggers for a role
         */
        negative_build_trigger_permissions: {
            build_trigger?: BuildTriggerIdentity | null;
        }[];
    };
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type RoleAttributes = {
    /**
     * The name of the role
     */
    name: string;
    /**
     * Can edit favicon, global SEO settings and no-index policy
     */
    can_edit_favicon: boolean;
    /**
     * Can change project name and 2FA settings
     */
    can_edit_site: boolean;
    /**
     * Can create/edit models and plugins
     */
    can_edit_schema: boolean;
    /**
     * Can customize content navigation bar
     */
    can_manage_menu: boolean;
    /**
     * Can change locales, timezone and UI theme
     */
    can_edit_environment: boolean;
    /**
     * Can promote environments to primary and manage maintenance mode
     */
    can_promote_environments: boolean;
    /**
     * Specifies the environments the user can access
     */
    environments_access: 'all' | 'primary_only' | 'sandbox_only';
    /**
     * Can create/edit roles and invite/remove collaborators
     */
    can_manage_users: boolean;
    /**
     * Can create/edit shared filters (both for models and the media area)
     */
    can_manage_shared_filters?: boolean;
    /**
     * Can create/edit Build triggers
     */
    can_manage_build_triggers: boolean;
    /**
     * Can create/edit webhooks
     */
    can_manage_webhooks: boolean;
    /**
     * Can create/delete sandbox environments and promote them to primary environment
     */
    can_manage_environments: boolean;
    /**
     * Can manage Single Sign-On settings
     */
    can_manage_sso: boolean;
    /**
     * Can access Audit Log
     */
    can_access_audit_log: boolean;
    /**
     * Can create/edit workflows
     */
    can_manage_workflows: boolean;
    /**
     * Can manage API tokens
     */
    can_manage_access_tokens: boolean;
    /**
     * Can perform Site Search API calls
     */
    can_perform_site_search: boolean;
    /**
     * Can access the build events log
     */
    can_access_build_events_log: boolean;
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_item_type_permissions: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_item_type_permissions: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_upload_permissions: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_upload_permissions: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed build triggers for a role
     */
    positive_build_trigger_permissions: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
    /**
     * Prohibited build triggers for a role
     */
    negative_build_trigger_permissions: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
};
/**
 * JSON API links
 *
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type RoleRelationships = {
    inherits_permissions_from: RoleData[];
};
/**
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type RoleCreateSchema = {
    type?: RoleType;
    /**
     * The name of the role
     */
    name: string;
    /**
     * Can edit favicon, global SEO settings and no-index policy
     */
    can_edit_favicon?: boolean;
    /**
     * Can change project name and 2FA settings
     */
    can_edit_site?: boolean;
    /**
     * Can create/edit models and plugins
     */
    can_edit_schema?: boolean;
    /**
     * Can customize content navigation bar
     */
    can_manage_menu?: boolean;
    /**
     * Can change locales, timezone and UI theme
     */
    can_edit_environment?: boolean;
    /**
     * Can promote environments to primary and manage maintenance mode
     */
    can_promote_environments?: boolean;
    /**
     * Specifies the environments the user can access
     */
    environments_access?: 'all' | 'primary_only' | 'sandbox_only';
    /**
     * Can create/edit roles and invite/remove collaborators
     */
    can_manage_users?: boolean;
    /**
     * Can create/edit shared filters (both for models and the media area)
     */
    can_manage_shared_filters?: boolean;
    /**
     * Can create/edit Build triggers
     */
    can_manage_build_triggers?: boolean;
    /**
     * Can create/edit webhooks
     */
    can_manage_webhooks?: boolean;
    /**
     * Can create/delete sandbox environments and promote them to primary environment
     */
    can_manage_environments?: boolean;
    /**
     * Can manage Single Sign-On settings
     */
    can_manage_sso?: boolean;
    /**
     * Can access Audit Log
     */
    can_access_audit_log?: boolean;
    /**
     * Can create/edit workflows
     */
    can_manage_workflows?: boolean;
    /**
     * Can manage API tokens
     */
    can_manage_access_tokens?: boolean;
    /**
     * Can perform Site Search API calls
     */
    can_perform_site_search?: boolean;
    /**
     * Can access the build events log
     */
    can_access_build_events_log?: boolean;
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_item_type_permissions?: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_item_type_permissions?: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_upload_permissions?: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_upload_permissions?: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed build triggers for a role
     */
    positive_build_trigger_permissions?: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
    /**
     * Prohibited build triggers for a role
     */
    negative_build_trigger_permissions?: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
    inherits_permissions_from?: RoleData[];
    meta?: RoleMeta;
};
/**
 * This interface was referenced by `Role`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type RoleUpdateSchema = {
    id?: RoleIdentity;
    type?: RoleType;
    /**
     * The name of the role
     */
    name?: string;
    /**
     * Can edit favicon, global SEO settings and no-index policy
     */
    can_edit_favicon?: boolean;
    /**
     * Can change project name and 2FA settings
     */
    can_edit_site?: boolean;
    /**
     * Can create/edit models and plugins
     */
    can_edit_schema?: boolean;
    /**
     * Can customize content navigation bar
     */
    can_manage_menu?: boolean;
    /**
     * Can change locales, timezone and UI theme
     */
    can_edit_environment?: boolean;
    /**
     * Can promote environments to primary and manage maintenance mode
     */
    can_promote_environments?: boolean;
    /**
     * Specifies the environments the user can access
     */
    environments_access?: 'all' | 'primary_only' | 'sandbox_only';
    /**
     * Can create/edit roles and invite/remove collaborators
     */
    can_manage_users?: boolean;
    /**
     * Can create/edit shared filters (both for models and the media area)
     */
    can_manage_shared_filters?: boolean;
    /**
     * Can create/edit Build triggers
     */
    can_manage_build_triggers?: boolean;
    /**
     * Can create/edit webhooks
     */
    can_manage_webhooks?: boolean;
    /**
     * Can create/delete sandbox environments and promote them to primary environment
     */
    can_manage_environments?: boolean;
    /**
     * Can manage Single Sign-On settings
     */
    can_manage_sso?: boolean;
    /**
     * Can access Audit Log
     */
    can_access_audit_log?: boolean;
    /**
     * Can create/edit workflows
     */
    can_manage_workflows?: boolean;
    /**
     * Can manage API tokens
     */
    can_manage_access_tokens?: boolean;
    /**
     * Can perform Site Search API calls
     */
    can_perform_site_search?: boolean;
    /**
     * Can access the build events log
     */
    can_access_build_events_log?: boolean;
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_item_type_permissions?: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_item_type_permissions?: {
        item_type?: ItemTypeIdentity | null;
        workflow?: WorkflowIdentity | null;
        on_stage?: null | string;
        to_stage?: null | string;
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'duplicate' | 'delete' | 'publish' | 'edit_creator' | 'take_over' | 'move_to_stage';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed actions on a model (or all) for a role
     */
    positive_upload_permissions?: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Prohibited actions on a model (or all) for a role
     */
    negative_upload_permissions?: {
        environment: EnvironmentIdentity;
        /**
         * Permitted action
         */
        action: 'all' | 'read' | 'update' | 'create' | 'delete' | 'edit_creator' | 'replace_asset';
        /**
         * Permitted creator
         */
        on_creator?: 'anyone' | 'self' | 'role' | null;
        /**
         * Permitted content scope
         */
        localization_scope?: 'all' | 'localized' | 'not_localized' | null;
        /**
         * Permitted localized content in this locale. Required when `localization_scope` is `localized`
         */
        locale?: string | null;
    }[];
    /**
     * Allowed build triggers for a role
     */
    positive_build_trigger_permissions?: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
    /**
     * Prohibited build triggers for a role
     */
    negative_build_trigger_permissions?: {
        build_trigger?: BuildTriggerIdentity | null;
    }[];
    inherits_permissions_from?: RoleData[];
    meta?: RoleMeta;
};
/**
 * A DatoCMS administrative area can be accessed by multiple people. Every collaborator is linked to a specific Role, which describes what actions it will be able to perform once logged in.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "user".
 */
export declare type User = {
    id: UserIdentity;
    type: UserType;
    /**
     * Email
     */
    email: string;
    /**
     * Whether 2-factor authentication is active for this account or not
     */
    is_2fa_active: boolean;
    /**
     * Full name
     */
    full_name: string;
    /**
     * Whether the user is active or not
     */
    is_active: boolean;
    role: RoleData;
    meta?: UserMeta;
};
export declare type UserUpdateTargetSchema = User;
export declare type UserSelfTargetSchema = User;
export declare type UserDestroyTargetSchema = User;
/**
 * Meta information on the user
 *
 * This interface was referenced by `User`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type UserMeta = {
    /**
     * Date of last reading/interaction
     */
    last_access: string | null;
};
/**
 * JSON API data
 *
 * This interface was referenced by `User`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type UserData = {
    type: UserType;
    id: UserIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `User`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type UserAttributes = {
    /**
     * Email
     */
    email: string;
    /**
     * Whether 2-factor authentication is active for this account or not
     */
    is_2fa_active: boolean;
    /**
     * Full name
     */
    full_name: string;
    /**
     * Whether the user is active or not
     */
    is_active: boolean;
};
/**
 * JSON API links
 *
 * This interface was referenced by `User`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type UserRelationships = {
    role: RoleData;
};
/**
 * This interface was referenced by `User`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type UserUpdateSchema = {
    id?: UserIdentity;
    type?: UserType;
    /**
     * Whether the user is active or not
     */
    is_active?: boolean;
    role?: RoleData;
};
/**
 * A Single Sign-On user exists when a DatoCMS project is connected to an external Identity Provider. An SSO user will not use the standard login procedure but has to go through SAML authentication. It can also be linked to one or more IdP groups.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "sso_user".
 */
export declare type SsoUser = {
    id: SsoUserIdentity;
    type: SsoUserType;
    /**
     * Email
     */
    username: string;
    /**
     * Identity provider ID
     */
    external_id: string | null;
    /**
     * Whether this user is active on the identity provider. De-activated users won't be able to login.
     */
    is_active: boolean;
    /**
     * First name
     */
    first_name: string | null;
    /**
     * Last name
     */
    last_name: string | null;
    groups: SsoGroupData[];
    role: RoleData | null;
    meta: SsoUserMeta;
};
export declare type SsoUserSelfTargetSchema = SsoUser;
export declare type SsoUserDestroyTargetSchema = SsoUser;
/**
 * JSON API data
 *
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SsoGroupData = {
    type: SsoGroupType;
    id: SsoGroupIdentity;
};
/**
 * Meta information on the user
 *
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type SsoUserMeta = {
    /**
     * Date of last reading/interaction
     */
    last_access: string | null;
};
/**
 * JSON API data
 *
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SsoUserData = {
    type: SsoUserType;
    id: SsoUserIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SsoUserAttributes = {
    /**
     * Email
     */
    username: string;
    /**
     * Identity provider ID
     */
    external_id: string | null;
    /**
     * Whether this user is active on the identity provider. De-activated users won't be able to login.
     */
    is_active: boolean;
    /**
     * First name
     */
    first_name: string | null;
    /**
     * Last name
     */
    last_name: string | null;
};
/**
 * JSON API links
 *
 * This interface was referenced by `SsoUser`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type SsoUserRelationships = {
    groups: SsoGroupData[];
    role: RoleData | null;
};
/**
 * An API token allows access to our API. It is linked to a Role, which describes what actions can be performed.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "access_token".
 */
export declare type AccessToken = {
    id: AccessTokenIdentity;
    type: AccessTokenType;
    /**
     * Name of API token
     */
    name: string;
    /**
     * The actual API token (or null if the current user has no permission to read the token)
     */
    token?: null | string;
    /**
     * Whether this API token can access the Content Delivery API published content endpoint
     */
    can_access_cda: boolean;
    /**
     * Whether this API token can access the Content Delivery API draft content endpoint
     */
    can_access_cda_preview: boolean;
    /**
     * Whether this API token can access the Content Management API
     */
    can_access_cma: boolean;
    hardcoded_type: null | string;
    role: RoleData | null;
};
export declare type AccessTokenCreateTargetSchema = AccessToken;
export declare type AccessTokenUpdateTargetSchema = AccessToken;
export declare type AccessTokenSelfTargetSchema = AccessToken;
export declare type AccessTokenRegenerateTokenTargetSchema = AccessToken;
export declare type AccessTokenDestroyTargetSchema = AccessToken;
/**
 * JSON API data
 *
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type AccessTokenData = {
    type: AccessTokenType;
    id: AccessTokenIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type AccessTokenAttributes = {
    /**
     * Name of API token
     */
    name: string;
    /**
     * The actual API token (or null if the current user has no permission to read the token)
     */
    token?: null | string;
    /**
     * Whether this API token can access the Content Delivery API published content endpoint
     */
    can_access_cda: boolean;
    /**
     * Whether this API token can access the Content Delivery API draft content endpoint
     */
    can_access_cda_preview: boolean;
    /**
     * Whether this API token can access the Content Management API
     */
    can_access_cma: boolean;
    hardcoded_type: null | string;
};
/**
 * JSON API links
 *
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type AccessTokenRelationships = {
    role: RoleData | null;
};
/**
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type AccessTokenCreateSchema = {
    type?: AccessTokenType;
    /**
     * Name of API token
     */
    name: string;
    /**
     * Whether this API token can access the Content Delivery API published content endpoint
     */
    can_access_cda: boolean;
    /**
     * Whether this API token can access the Content Delivery API draft content endpoint
     */
    can_access_cda_preview: boolean;
    /**
     * Whether this API token can access the Content Management API
     */
    can_access_cma: boolean;
    role: RoleData | null;
};
/**
 * This interface was referenced by `AccessToken`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type AccessTokenUpdateSchema = {
    id?: AccessTokenIdentity;
    type?: AccessTokenType;
    /**
     * Name of API token
     */
    name: string;
    /**
     * Whether this API token can access the Content Delivery API published content endpoint
     */
    can_access_cda: boolean;
    /**
     * Whether this API token can access the Content Delivery API draft content endpoint
     */
    can_access_cda_preview: boolean;
    /**
     * Whether this API token can access the Content Management API
     */
    can_access_cma: boolean;
    role: RoleData | null;
};
/**
 * DatoCMS account
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "account".
 */
export declare type Account = {
    id: AccountIdentity;
    type: AccountType;
    /**
     * Email
     */
    email: string;
    /**
     * First name
     */
    first_name: string | null;
    /**
     * Last name
     */
    last_name: string | null;
    /**
     * Company name
     */
    company: string | null;
    /**
     * Password
     */
    password?: string;
};
/**
 * JSON API data
 *
 * This interface was referenced by `Account`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type AccountData = {
    type: AccountType;
    id: AccountIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `Account`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type AccountAttributes = {
    /**
     * Email
     */
    email: string;
    /**
     * First name
     */
    first_name: string | null;
    /**
     * Last name
     */
    last_name: string | null;
    /**
     * Company name
     */
    company: string | null;
    /**
     * Password
     */
    password?: string;
};
/**
 * If the Audit log functionality is enabled in a project, logged events can be queried using SQL-like language and fetched in full detail so that they can be exported or analyzed.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "audit_log_event".
 */
export declare type AuditLogEvent = {
    id: AuditLogEventIdentity;
    type: AuditLogEventType;
    /**
     * The actual action performed
     */
    action_name: string;
    /**
     * The actor who performed the action
     */
    actor: {
        /**
         * The type of actor (can be `account`, `user`, `sso_user` or `access_token`)
         */
        type: string;
        /**
         * The ID of the actor
         */
        id: string;
        /**
         * An human representation of the actor (name/email/username depending on the type of actor)
         */
        name: string;
    };
    /**
     * The role of the actor at the time the action was performed
     */
    role: null | {
        /**
         * The name of the role
         */
        name: string;
        /**
         * The ID of the role
         */
        id: string;
    };
    /**
     * The environment inside of which the action was performed
     */
    environment: {
        /**
         * The ID of the environment
         */
        id: string;
        /**
         * Whether the environment was the primary one at the time the action was performed
         */
        primary: boolean;
    };
    /**
     * The actual request being performed
     */
    request: {
        /**
         * The full path of the request
         */
        path: string;
        /**
         * The HTTP method of the request
         */
        method: string;
        /**
         * The X-Request-ID header of the request
         */
        id?: string;
        /**
         * The full HTTP body of the request
         */
        payload?: null | {
            [k: string]: unknown;
        };
    };
    /**
     * The actual response being returned by DatoCMS
     */
    response: null | {
        /**
         * The HTTP status code of the response
         */
        status: number;
        /**
         * The full HTTP body of the response
         */
        payload: {
            [k: string]: unknown;
        };
    };
    meta: AuditLogEventMeta;
};
/**
 * JSON API meta
 *
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type AuditLogEventMeta = {
    /**
     * The date of the event
     */
    occurred_at: string;
};
/**
 * JSON API data
 *
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type AuditLogEventData = {
    type: AuditLogEventType;
    id: AuditLogEventIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type AuditLogEventAttributes = {
    /**
     * The actual action performed
     */
    action_name: string;
    /**
     * The actor who performed the action
     */
    actor: {
        /**
         * The type of actor (can be `account`, `user`, `sso_user` or `access_token`)
         */
        type: string;
        /**
         * The ID of the actor
         */
        id: string;
        /**
         * An human representation of the actor (name/email/username depending on the type of actor)
         */
        name: string;
    };
    /**
     * The role of the actor at the time the action was performed
     */
    role: null | {
        /**
         * The name of the role
         */
        name: string;
        /**
         * The ID of the role
         */
        id: string;
    };
    /**
     * The environment inside of which the action was performed
     */
    environment: {
        /**
         * The ID of the environment
         */
        id: string;
        /**
         * Whether the environment was the primary one at the time the action was performed
         */
        primary: boolean;
    };
    /**
     * The actual request being performed
     */
    request: {
        /**
         * The full path of the request
         */
        path: string;
        /**
         * The HTTP method of the request
         */
        method: string;
        /**
         * The X-Request-ID header of the request
         */
        id?: string;
        /**
         * The full HTTP body of the request
         */
        payload?: null | {
            [k: string]: unknown;
        };
    };
    /**
     * The actual response being returned by DatoCMS
     */
    response: null | {
        /**
         * The HTTP status code of the response
         */
        status: number;
        /**
         * The full HTTP body of the response
         */
        payload: {
            [k: string]: unknown;
        };
    };
};
/**
 * This interface was referenced by `AuditLogEvent`'s JSON-Schema
 * via the `query.schema` link.
 */
export declare type AuditLogEventQuerySchema = {
    /**
     * JSON API type field
     */
    type?: 'audit_log_query';
    /**
     * An SQL-like expression to filter the events
     */
    filter?: string;
    /**
     * Set this value to get remaining results, if a meta.next_token was returned in the previous query response
     */
    next_token?: string;
    /**
     * Whether a detailed log complete with full request and response payload must be returned or not
     */
    detailed_log?: boolean;
};
/**
 * Stores the information regarding the current plan for the project.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "site_plan".
 */
export declare type SitePlan = {
    id: SitePlanIdentity;
    type: SitePlanType;
    /**
     * The name of the plan
     */
    name: string;
    /**
     * Whether this plan is active or legacy
     */
    active: boolean;
    /**
     * Whether custom domain can be enabled or not
     */
    custom_domain: boolean;
    /**
     * Number of users that can be invited
     */
    users: null | number;
    /**
     * Number of indexable pages
     */
    indexable_pages: null | number;
    /**
     * Number of build triggers
     */
    build_triggers: null | number;
    /**
     * Number of plugins
     */
    plugins: null | number;
    /**
     * Number of webhooks
     */
    webhooks: null | number;
    /**
     * Number of records allowed
     */
    items: null | number;
    /**
     * Monthly price
     */
    monthly_price: number;
    /**
     * Yearly price
     */
    yearly_price: number;
    /**
     * Uploadable bytes
     */
    uploadable_bytes: null | number;
    /**
     * Amount of asset data transferred between our Asset CDN and GraphQL Content Delivery API and content consumers
     */
    traffic_bytes: null | number;
    /**
     * The number of requests made to both our Content Management and Content Delivery APIs
     */
    api_calls: null | number;
    /**
     * The number of streaming seconds delivered by Mux.com
     */
    mux_streaming_seconds: null | number;
    /**
     * The number of available encoding seconds to Mux.com
     */
    mux_encoding_seconds: null | number;
    /**
     * The number of different API tokens you can generate, each which different permissions
     */
    access_tokens: null | number;
    /**
     * Number of roles allowed
     */
    roles: null | number;
    /**
     * Number of locales allowed
     */
    locales: null | number;
    /**
     * Number of sandbox environments allowed
     */
    sandbox_environments: null | number;
    /**
     * Number of models allowed
     */
    item_types: null | number;
    /**
     * Whether collaboration features are enabled or not
     */
    item_locking: boolean;
    /**
     * Whether project is in white-label mode or not
     */
    white_label: boolean;
    /**
     * Whether Single Sign-On feature is enabled or not
     */
    sso: boolean;
    /**
     * Whether built-in image editor and smart-tagging is enabled or not
     */
    advanced_media_area: boolean;
    /**
     * Maximum number of blocks a record can contain
     */
    blocks_per_item: number;
    /**
     * Maximum level of block nesting for a record
     */
    blocks_depth: number;
    /**
     * Whether video streaming with Mux.com is enabled or not
     */
    video: boolean;
    /**
     * Days of version history retention
     */
    history_retention_days: number | null;
    /**
     * Maximum number of clients connected at the same time to the Realtime Updates API. The limit is per-project
     */
    concurrent_realtime_connections: number;
    /**
     * Period (in minutes) in which bursts of changes made to the same record by the same user (or API token) will be grouped into a single one
     */
    history_resolution_minutes: number;
    /**
     * Whether two-factor authentication can be enabled or not
     */
    otp: boolean;
    /**
     * Whether workflows are enabled or not
     */
    workflows: boolean;
    /**
     * Number of workflows allowed
     */
    workflows_count: number;
    /**
     * Whether audit logs are enabled or not
     */
    audit_log: boolean;
    /**
     * Whether translator roles are enabled or not
     */
    translator_roles: boolean;
    /**
     * Whether or not use a static IP when sending webhooks
     */
    static_webhooks_ip: boolean;
    /**
     * Maximum size in bytes for a single file upload
     */
    maximum_single_upload_bytes: number;
    /**
     * Available extra packets
     */
    extra_packets: {
        users?: {
            amount_per_packet: number;
            price: number;
        };
        locales?: {
            amount_per_packet: number;
            price: number;
        };
        item_types?: {
            amount_per_packet: number;
            price: number;
        };
        roles?: {
            amount_per_packet: number;
            price: number;
        };
        build_triggers?: {
            amount_per_packet: number;
            price: number;
        };
        access_tokens?: {
            amount_per_packet: number;
            price: number;
        };
        mux_encoding_seconds?: {
            amount_per_packet: number;
            price: number;
        };
        sandbox_environments?: {
            amount_per_packet: number;
            price: number;
        };
    };
    /**
     * Automatic packets
     */
    auto_packets: {
        traffic_bytes?: {
            amount_per_packet: number;
            price: number;
        };
        api_calls?: {
            amount_per_packet: number;
            price: number;
        };
        mux_streaming_seconds?: {
            amount_per_packet: number;
            price: number;
        };
    };
};
/**
 * JSON API data
 *
 * This interface was referenced by `SitePlan`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SitePlanData = {
    type: SitePlanType;
    id: SitePlanIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `SitePlan`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SitePlanAttributes = {
    /**
     * The name of the plan
     */
    name: string;
    /**
     * Whether this plan is active or legacy
     */
    active: boolean;
    /**
     * Whether custom domain can be enabled or not
     */
    custom_domain: boolean;
    /**
     * Number of users that can be invited
     */
    users: null | number;
    /**
     * Number of indexable pages
     */
    indexable_pages: null | number;
    /**
     * Number of build triggers
     */
    build_triggers: null | number;
    /**
     * Number of plugins
     */
    plugins: null | number;
    /**
     * Number of webhooks
     */
    webhooks: null | number;
    /**
     * Number of records allowed
     */
    items: null | number;
    /**
     * Monthly price
     */
    monthly_price: number;
    /**
     * Yearly price
     */
    yearly_price: number;
    /**
     * Uploadable bytes
     */
    uploadable_bytes: null | number;
    /**
     * Amount of asset data transferred between our Asset CDN and GraphQL Content Delivery API and content consumers
     */
    traffic_bytes: null | number;
    /**
     * The number of requests made to both our Content Management and Content Delivery APIs
     */
    api_calls: null | number;
    /**
     * The number of streaming seconds delivered by Mux.com
     */
    mux_streaming_seconds: null | number;
    /**
     * The number of available encoding seconds to Mux.com
     */
    mux_encoding_seconds: null | number;
    /**
     * The number of different API tokens you can generate, each which different permissions
     */
    access_tokens: null | number;
    /**
     * Number of roles allowed
     */
    roles: null | number;
    /**
     * Number of locales allowed
     */
    locales: null | number;
    /**
     * Number of sandbox environments allowed
     */
    sandbox_environments: null | number;
    /**
     * Number of models allowed
     */
    item_types: null | number;
    /**
     * Whether collaboration features are enabled or not
     */
    item_locking: boolean;
    /**
     * Whether project is in white-label mode or not
     */
    white_label: boolean;
    /**
     * Whether Single Sign-On feature is enabled or not
     */
    sso: boolean;
    /**
     * Whether built-in image editor and smart-tagging is enabled or not
     */
    advanced_media_area: boolean;
    /**
     * Maximum number of blocks a record can contain
     */
    blocks_per_item: number;
    /**
     * Maximum level of block nesting for a record
     */
    blocks_depth: number;
    /**
     * Whether video streaming with Mux.com is enabled or not
     */
    video: boolean;
    /**
     * Days of version history retention
     */
    history_retention_days: number | null;
    /**
     * Maximum number of clients connected at the same time to the Realtime Updates API. The limit is per-project
     */
    concurrent_realtime_connections: number;
    /**
     * Period (in minutes) in which bursts of changes made to the same record by the same user (or API token) will be grouped into a single one
     */
    history_resolution_minutes: number;
    /**
     * Whether two-factor authentication can be enabled or not
     */
    otp: boolean;
    /**
     * Whether workflows are enabled or not
     */
    workflows: boolean;
    /**
     * Number of workflows allowed
     */
    workflows_count: number;
    /**
     * Whether audit logs are enabled or not
     */
    audit_log: boolean;
    /**
     * Whether translator roles are enabled or not
     */
    translator_roles: boolean;
    /**
     * Whether or not use a static IP when sending webhooks
     */
    static_webhooks_ip: boolean;
    /**
     * Maximum size in bytes for a single file upload
     */
    maximum_single_upload_bytes: number;
    /**
     * Available extra packets
     */
    extra_packets: {
        users?: {
            amount_per_packet: number;
            price: number;
        };
        locales?: {
            amount_per_packet: number;
            price: number;
        };
        item_types?: {
            amount_per_packet: number;
            price: number;
        };
        roles?: {
            amount_per_packet: number;
            price: number;
        };
        build_triggers?: {
            amount_per_packet: number;
            price: number;
        };
        access_tokens?: {
            amount_per_packet: number;
            price: number;
        };
        mux_encoding_seconds?: {
            amount_per_packet: number;
            price: number;
        };
        sandbox_environments?: {
            amount_per_packet: number;
            price: number;
        };
    };
    /**
     * Automatic packets
     */
    auto_packets: {
        traffic_bytes?: {
            amount_per_packet: number;
            price: number;
        };
        api_calls?: {
            amount_per_packet: number;
            price: number;
        };
        mux_streaming_seconds?: {
            amount_per_packet: number;
            price: number;
        };
    };
};
/**
 * In DatoCMS you can organize the different Models present in your administrative area reordering and grouping them, so that their purpose will be more clear to the final editor.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "menu_item".
 */
export declare type MenuItem = {
    id: MenuItemIdentity;
    type: MenuItemType;
    /**
     * The label of the menu item
     */
    label: string;
    /**
     * The URL to which the menu item points to
     */
    external_url: null | string;
    /**
     * Ordering index
     */
    position: number;
    /**
     * Opens link in new tab (used together with `external_url`)
     */
    open_in_new_tab: boolean;
    item_type: ItemTypeData | null;
    parent: null | MenuItemData;
    children: MenuItemData[];
};
export declare type MenuItemCreateTargetSchema = MenuItem;
export declare type MenuItemUpdateTargetSchema = MenuItem;
export declare type MenuItemSelfTargetSchema = MenuItem;
export declare type MenuItemDestroyTargetSchema = MenuItem;
/**
 * JSON API data
 *
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type ItemTypeData = {
    type: ItemTypeType;
    id: ItemTypeIdentity;
};
/**
 * JSON API data
 *
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type MenuItemData = {
    type: MenuItemType;
    id: MenuItemIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type MenuItemAttributes = {
    /**
     * The label of the menu item
     */
    label: string;
    /**
     * The URL to which the menu item points to
     */
    external_url: null | string;
    /**
     * Ordering index
     */
    position: number;
    /**
     * Opens link in new tab (used together with `external_url`)
     */
    open_in_new_tab: boolean;
};
/**
 * JSON API links
 *
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type MenuItemRelationships = {
    item_type: ItemTypeData | null;
    parent: null | MenuItemData;
    children: MenuItemData[];
};
/**
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type MenuItemCreateSchema = {
    type?: MenuItemType;
    /**
     * The label of the menu item
     */
    label: string;
    /**
     * The URL to which the menu item points to
     */
    external_url?: null | string;
    /**
     * Ordering index
     */
    position: number;
    /**
     * Opens link in new tab (used together with `external_url`)
     */
    open_in_new_tab?: boolean;
    item_type?: ItemTypeData | null;
    parent?: null | MenuItemData;
};
/**
 * This interface was referenced by `MenuItem`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type MenuItemUpdateSchema = {
    id?: MenuItemIdentity;
    type?: MenuItemType;
    /**
     * The label of the menu item
     */
    label?: string;
    /**
     * The URL to which the menu item points to
     */
    external_url?: null | string;
    /**
     * Ordering index
     */
    position?: number;
    /**
     * Opens link in new tab (used together with `external_url`)
     */
    open_in_new_tab?: boolean;
    item_type?: ItemTypeData | null;
    parent?: null | MenuItemData;
};
/**
 * The way you define the kind of content you can edit inside your administrative area passes through the concept of Models, which are much like database tables. For backward-compatibility reasons, the API refers to models as "item types".
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "item_type".
 */
export declare type ItemType = {
    id: ItemTypeIdentity;
    type: ItemTypeType;
    /**
     * Name of the model
     */
    name: string;
    /**
     * API key of the model
     */
    api_key: string;
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appeareance: 'compact' | 'table';
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appearance: 'compact' | 'table';
    /**
     * Whether the model is single-instance or not
     */
    singleton: boolean;
    /**
     * Whether we require all the project locales to be present for each localized field or not
     */
    all_locales_required: boolean;
    /**
     * Whether editors can sort records via drag & drop or not
     */
    sortable: boolean;
    /**
     * Whether this model is a modular content block or not
     */
    modular_block: boolean;
    /**
     * Whether draft/published mode is active or not
     */
    draft_mode_active: boolean;
    /**
     * Whether editors can organize records in a tree or not
     */
    tree: boolean;
    /**
     * If an ordering field is set, this fields specify the sorting direction
     */
    ordering_direction: null | 'asc' | 'desc';
    /**
     * Specifies the model's sorting method. Cannot be set in concurrency with ordering_field
     */
    ordering_meta: null | 'created_at' | 'updated_at' | 'first_published_at' | 'published_at';
    /**
     * If this model is single-instance, this tells the single-instance record has already been created or not
     */
    has_singleton_item: boolean;
    /**
     * A hint shown to editors to help them understand the purpose of this model/block
     */
    hint: string | null;
    singleton_item: ItemData | null;
    fields: FieldData[];
    fieldsets: FieldsetData[];
    title_field: FieldData | null;
    image_preview_field: FieldData | null;
    excerpt_field: FieldData | null;
    ordering_field: FieldData | null;
    workflow: WorkflowData | null;
};
export declare type ItemTypeCreateTargetSchema = ItemType;
export declare type ItemTypeUpdateJobSchema = ItemType;
export declare type ItemTypeSelfTargetSchema = ItemType;
export declare type ItemTypeDuplicateTargetSchema = ItemType;
export declare type ItemTypeDestroyJobSchema = ItemType;
/**
 * JSON API data
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type ItemData = {
    type: ItemType1;
    id: ItemIdentity;
};
/**
 * JSON API data
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type FieldData = {
    type: FieldType;
    id: FieldIdentity;
};
/**
 * JSON API data
 *
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type FieldsetData = {
    type: FieldsetType;
    id: FieldsetIdentity;
};
/**
 * JSON API data
 *
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type WorkflowData = {
    type: WorkflowType;
    id: WorkflowIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type ItemTypeAttributes = {
    /**
     * Name of the model
     */
    name: string;
    /**
     * API key of the model
     */
    api_key: string;
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appeareance: 'compact' | 'table';
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appearance: 'compact' | 'table';
    /**
     * Whether the model is single-instance or not
     */
    singleton: boolean;
    /**
     * Whether we require all the project locales to be present for each localized field or not
     */
    all_locales_required: boolean;
    /**
     * Whether editors can sort records via drag & drop or not
     */
    sortable: boolean;
    /**
     * Whether this model is a modular content block or not
     */
    modular_block: boolean;
    /**
     * Whether draft/published mode is active or not
     */
    draft_mode_active: boolean;
    /**
     * Whether editors can organize records in a tree or not
     */
    tree: boolean;
    /**
     * If an ordering field is set, this fields specify the sorting direction
     */
    ordering_direction: null | 'asc' | 'desc';
    /**
     * Specifies the model's sorting method. Cannot be set in concurrency with ordering_field
     */
    ordering_meta: null | 'created_at' | 'updated_at' | 'first_published_at' | 'published_at';
    /**
     * If this model is single-instance, this tells the single-instance record has already been created or not
     */
    has_singleton_item: boolean;
    /**
     * A hint shown to editors to help them understand the purpose of this model/block
     */
    hint: string | null;
};
/**
 * JSON API links
 *
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type ItemTypeRelationships = {
    singleton_item: ItemData | null;
    fields: FieldData[];
    fieldsets: FieldsetData[];
    title_field: FieldData | null;
    image_preview_field: FieldData | null;
    excerpt_field: FieldData | null;
    ordering_field: FieldData | null;
    workflow: WorkflowData | null;
};
/**
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type ItemTypeCreateSchema = {
    type?: ItemTypeType;
    /**
     * Name of the model
     */
    name: string;
    /**
     * API key of the model
     */
    api_key: string;
    /**
     * Whether the model is single-instance or not
     */
    singleton?: boolean;
    /**
     * Whether we require all the project locales to be present for each localized field or not
     */
    all_locales_required?: boolean;
    /**
     * Whether editors can sort records via drag & drop or not
     */
    sortable?: boolean;
    /**
     * Whether this model is a modular content block or not
     */
    modular_block?: boolean;
    /**
     * Whether draft/published mode is active or not
     */
    draft_mode_active?: boolean;
    /**
     * Whether editors can organize records in a tree or not
     */
    tree?: boolean;
    /**
     * If an ordering field is set, this fields specify the sorting direction
     */
    ordering_direction?: null | 'asc' | 'desc';
    /**
     * Specifies the model's sorting method. Cannot be set in concurrency with ordering_field
     */
    ordering_meta?: null | 'created_at' | 'updated_at' | 'first_published_at' | 'published_at';
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appeareance?: 'compact' | 'table';
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appearance?: 'compact' | 'table';
    /**
     * A hint shown to editors to help them understand the purpose of this model/block
     */
    hint?: string | null;
    ordering_field?: FieldData | null;
    title_field?: FieldData | null;
    image_preview_field?: FieldData | null;
    excerpt_field?: FieldData | null;
    workflow?: WorkflowData | null;
};
/**
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type ItemTypeUpdateSchema = {
    id?: ItemTypeIdentity;
    type?: ItemTypeType;
    /**
     * Name of the model
     */
    name?: string;
    /**
     * API key of the model
     */
    api_key?: string;
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appeareance?: 'compact' | 'table';
    /**
     * The way the model collection should be presented to the editors
     */
    collection_appearance?: 'compact' | 'table';
    /**
     * Whether the model is single-instance or not
     */
    singleton?: boolean;
    /**
     * Whether we require all the project locales to be present for each localized field or not
     */
    all_locales_required?: boolean;
    /**
     * Whether editors can sort records via drag & drop or not
     */
    sortable?: boolean;
    /**
     * Whether this model is a modular content block or not
     */
    modular_block?: boolean;
    /**
     * Whether draft/published mode is active or not
     */
    draft_mode_active?: boolean;
    /**
     * Whether editors can organize records in a tree or not
     */
    tree?: boolean;
    /**
     * If an ordering field is set, this fields specify the sorting direction
     */
    ordering_direction?: null | 'asc' | 'desc';
    /**
     * Specifies the model's sorting method. Cannot be set in concurrency with ordering_field
     */
    ordering_meta?: null | 'created_at' | 'updated_at' | 'first_published_at' | 'published_at';
    /**
     * If this model is single-instance, this tells the single-instance record has already been created or not
     */
    has_singleton_item?: boolean;
    /**
     * A hint shown to editors to help them understand the purpose of this model/block
     */
    hint?: string | null;
    ordering_field?: FieldData | null;
    title_field?: FieldData | null;
    image_preview_field?: FieldData | null;
    excerpt_field?: FieldData | null;
    workflow?: WorkflowData | null;
};
/**
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `update.targetSchema` link.
 *
 * This interface was referenced by `ItemType`'s JSON-Schema
 * via the `destroy.targetSchema` link.
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `create.targetSchema` link.
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `update.targetSchema` link.
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `destroy.targetSchema` link.
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `duplicate.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `duplicate.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `destroy.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_destroy.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_publish.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `batch_unpublish.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_publish.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_unpublish.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_destroy.targetSchema` link.
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_move_to_stage.targetSchema` link.
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `restore.targetSchema` link.
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `create.targetSchema` link.
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `update.targetSchema` link.
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `batch_add_tags.targetSchema` link.
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `batch_destroy.targetSchema` link.
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `bulk_tag.targetSchema` link.
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `bulk_destroy.targetSchema` link.
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `update.targetSchema` link.
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `activate_improved_timezone_management.targetSchema` link.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "job".
 */
export declare type Job = {
    id: JobIdentity;
    type: JobType;
};
export declare type ItemTypeUpdateTargetSchema = Job;
export declare type ItemTypeDestroyTargetSchema = Job;
export declare type FieldCreateTargetSchema = Job;
export declare type FieldUpdateTargetSchema = Job;
export declare type FieldDestroyTargetSchema = Job;
export declare type FieldDuplicateTargetSchema = Job;
export declare type ItemDuplicateTargetSchema = Job;
export declare type ItemDestroyTargetSchema = Job;
export declare type ItemBatchDestroyTargetSchema = Job;
export declare type ItemBatchPublishTargetSchema = Job;
export declare type ItemBatchUnpublishTargetSchema = Job;
export declare type ItemBulkPublishTargetSchema = Job;
export declare type ItemBulkUnpublishTargetSchema = Job;
export declare type ItemBulkDestroyTargetSchema = Job;
export declare type ItemBulkMoveToStageTargetSchema = Job;
export declare type ItemVersionRestoreTargetSchema = Job;
export declare type UploadCreateTargetSchema = Job;
export declare type UploadUpdateTargetSchema = Job;
export declare type UploadBatchAddTagsTargetSchema = Job;
export declare type UploadBatchDestroyTargetSchema = Job;
export declare type UploadBulkTagTargetSchema = Job;
export declare type UploadBulkDestroyTargetSchema = Job;
export declare type SiteUpdateTargetSchema = Job;
export declare type SiteActivateImprovedTimezoneManagementTargetSchema = Job;
/**
 * JSON API data
 *
 * This interface was referenced by `Job`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type JobData = {
    type: JobType;
    id: JobIdentity;
};
/**
 * DatoCMS offers a number of different fields that you can combine togheter to create a [Model](/docs/content-management-api/resources/item-type). Using the database metaphore, fields are like table columns, and when creating them you need to specify their type (`string`, `float`, etc.) and any required validation.
 *
 * ### Different field types require different settings
 *
 * When looking at a field resource, you have to pay attention to two particular properties, `validators` and `appearance`.
 *
 * The `validators` property expresses the set of validations to be performed server-side on a specific field value for it to be considered valid, while the `appearance` property lets you specify _how_ the field itself will be presented inside the form to the final editor.
 *
 * For both properties, the value to specify depends on the type of field itself. For example, you can add a "Limit character count" validation to a _Single-line string_ field, or set its appearence to "Show it as heading", but they won't be accepted for a ie. _Color_ field, as it supports different validations and appearance settings.
 *
 * ### Specifying validations
 *
 * The `validators` property requires an object whose keys are the validations that you want to be enforced, and the values are objects representing any settings that the validation itself requires. If the validation doesn't have additional settings, you just pass down an empty object.
 *
 * This is a valid example for a _Single-line string_ field:
 *
 * ```js
 * {
 *   "validators": {
 *     // "required" validator has no settings
 *     "required": {},
 *     // "length" validator requires "min" and/or "max" properties
 *     "length": { "min": 80 }
 *   }
 * }
 * ```
 *
 * Below you'll find a summary of all the validators available for each field type with their settings.
 *
 * Some validators are required for a specific type of field. For example, the _Slug_ field needs to have a `slug_title_field` validator to specify the ID of the _Single-line string_ field that will be used to generate the slug itself.
 *
 * ### Specifying the appearance
 *
 * The `appearance` property requires an object with three specific properties: `editor`, `parameters` and `addons`.
 *
 * The `editor` represents the type of editor that the users will see inside the form to change the value of this specific field. Depending on the type of field, DatoCMS offers a number of different editors for you to choose from. The `parameters` property is an object representing any additional settings that the editor itself might require.
 *
 * This is a valid example for a _Single-line string_ field:
 *
 * ```js
 * {
 *   "appearance": {
 *     // single_line is a DatoCMS built-in editor that you can use with single-line string fields
 *     "editor": "single_line",
 *     // each built-in editor has specific settings
 *     "parameters": { "heading": true },
 *     "addons": []
 *   },
 * }
 * ```
 *
 * Following you'll find a summary of all the editors available for each field type with their settings.
 *
 * #### Setting the appearance to a field editor provided by a plugin
 *
 * If the project contains a plugin that exposes [manual field editors](/docs/plugin-sdk/manual-field-extensions), you can also configure the field to be presented with it instead of using one of the build-in editors.
 *
 * In this case:
 *
 * - the `editor` property must be the ID of the plugin;
 * - the `field_extension` property must be the ID of the specific manual field editor that the plugin exposes;
 * - the `parameters` property must provide a configuration object compatible with the [config screen of the manual field extension](/docs/plugin-sdk/manual-field-extensions#add-per-field-config-screens-to-manual-field-extensions), or an empty object if it doesn't require any configuration.
 *
 * ```js
 * {
 *   "appearance": {
 *     // "2132" is a the ID of a plugin exposing a manual field editor
 *     "editor": "2134",
 *     // "starRating" is a manual field editor exposed by the plugin
 *     "field_extension": "starRating",
 *     // this is a valid configuration for the "starRating" field editor
 *     "parameters": { "maxRating": 5, "starsColor": "#ff0000" },
 *     "addons": []
 *   },
 * }
 * ```
 *
 * #### Configuring manual field addons
 *
 * If the project contains plugins that expose [manual field addons](/docs/plugin-sdk/manual-field-extensions), you can also add them to the field via the `addons` property.
 *
 * ```js
 * {
 *   "appearance": {
 *     "editor": "single_line",
 *     "parameters": { "heading": true },
 *     "addons": [
 *       {
 *         // "2138" is a the ID of a plugin exposing a manual addon editor
 *         "id": "2138",
 *         // "loremIpsumGenerator" is a manual field addon exposed by the plugin
 *         "field_extension": "loremIpsumGenerator",
 *         // this is a valid configuration for the "loremIpsumGenerator" field addon
 *         "parameters": { "sentences": 2 },
 *       }
 *     ]
 *   },
 * }
 * ```
 *
 * ### Available field types
 *
 * <details>
 * <summary>Single-line string (<code>string</code>)</summary>
 *
 * | Property                       | Value                                                |
 * | ------------------------------ | ---------------------------------------------------- |
 * | Code                           | `string`                                             |
 * | Built-in editors for the field | `single_line`, `string_radio_group`, `string_select` |
 * | Available validators           | `required`, `unique`, `length`, `format`, `enum`     |
 *
 * </details>
 *
 * <details>
 * <summary>Multi-line text (<code>text</code>)</summary>
 *
 * | Property                       | Value                             |
 * | ------------------------------ | --------------------------------- |
 * | Code                           | `text`                            |
 * | Built-in editors for the field | `markdown`, `wysiwyg`, `textarea` |
 * | Available validators           | `required`, `length`, `format`    |
 *
 * </details>
 *
 * <details>
 * <summary>Boolean (<code>boolean</code>)</summary>
 *
 * | Property                       | Value                            |
 * | ------------------------------ | -------------------------------- |
 * | Code                           | `boolean`                        |
 * | Built-in editors for the field | `boolean`, `boolean_radio_group` |
 * | Available validators           | no validators available          |
 *
 * </details>
 *
 * <details>
 * <summary>Integer (<code>integer</code>)</summary>
 *
 * | Property                       | Value                      |
 * | ------------------------------ | -------------------------- |
 * | Code                           | `integer`                  |
 * | Built-in editors for the field | `integer`                  |
 * | Available validators           | `required`, `number_range` |
 *
 * </details>
 *
 * <details>
 * <summary>Float (<code>float</code>)</summary>
 *
 * | Property                       | Value                      |
 * | ------------------------------ | -------------------------- |
 * | Code                           | `float`                    |
 * | Built-in editors for the field | `float`                    |
 * | Available validators           | `required`, `number_range` |
 *
 * </details>
 *
 * <details>
 * <summary>Date (<code>date</code>)</summary>
 *
 * | Property                       | Value                    |
 * | ------------------------------ | ------------------------ |
 * | Code                           | `date`                   |
 * | Built-in editors for the field | `date_picker`            |
 * | Available validators           | `required`, `date_range` |
 *
 * </details>
 *
 * <details>
 * <summary>Date time (<code>date_time</code>)</summary>
 *
 * | Property                       | Value                         |
 * | ------------------------------ | ----------------------------- |
 * | Code                           | `date_time`                   |
 * | Built-in editors for the field | `date_time_picker`            |
 * | Available validators           | `required`, `date_time_range` |
 *
 * </details>
 *
 * <details>
 * <summary>Color (<code>color</code>)</summary>
 *
 * | Property                       | Value          |
 * | ------------------------------ | -------------- |
 * | Code                           | `color`        |
 * | Built-in editors for the field | `color_picker` |
 * | Available validators           | `required`     |
 *
 * </details>
 *
 * <details>
 * <summary>JSON (<code>json</code>)</summary>
 *
 * | Property                       | Value                                                  |
 * | ------------------------------ | ------------------------------------------------------ |
 * | Code                           | `json`                                                 |
 * | Built-in editors for the field | `json`, `string_multi_select`, `string_checkbox_group` |
 * | Available validators           | `required`                                             |
 *
 * </details>
 *
 * <details>
 * <summary>Location (<code>lat_lon</code>)</summary>
 *
 * | Property                       | Value      |
 * | ------------------------------ | ---------- |
 * | Code                           | `lat_lon`  |
 * | Built-in editors for the field | `map`      |
 * | Available validators           | `required` |
 *
 * </details>
 *
 * <details>
 * <summary>SEO (<code>seo</code>)</summary>
 *
 * | Property                       | Value                                                                                        |
 * | ------------------------------ | -------------------------------------------------------------------------------------------- |
 * | Code                           | `seo`                                                                                        |
 * | Built-in editors for the field | `seo`                                                                                        |
 * | Available validators           | `required_seo_fields`, `file_size`, `image_dimensions`, `title_length`, `description_length` |
 *
 * </details>
 *
 * <details>
 * <summary>Slug (<code>slug</code>)</summary>
 *
 * | Property                       | Value                               |
 * | ------------------------------ | ----------------------------------- |
 * | Code                           | `slug`                              |
 * | Built-in editors for the field | `slug`                              |
 * | Required validators            | `slug_title_field`                  |
 * | Other validators available     | `required`, `length`, `slug_format` |
 *
 * </details>
 *
 * <details>
 * <summary>External video (<code>video</code>)</summary>
 *
 * | Property                       | Value      |
 * | ------------------------------ | ---------- |
 * | Code                           | `video`    |
 * | Built-in editors for the field | `video`    |
 * | Available validators           | `required` |
 *
 * </details>
 *
 * <details>
 * <summary>Single-asset (<code>file</code>)</summary>
 *
 * | Property                       | Value                                                                          |
 * | ------------------------------ | ------------------------------------------------------------------------------ |
 * | Code                           | `file`                                                                         |
 * | Built-in editors for the field | `file`                                                                         |
 * | Available validators           | `required`, `file_size`, `image_dimensions`, `extension`, `required_alt_title` |
 *
 * </details>
 *
 * <details>
 * <summary>Asset gallery (<code>gallery</code>)</summary>
 *
 * | Property                       | Value                                                                      |
 * | ------------------------------ | -------------------------------------------------------------------------- |
 * | Code                           | `gallery`                                                                  |
 * | Built-in editors for the field | `gallery`                                                                  |
 * | Available validators           | `size`, `file_size`, `image_dimensions`, `extension`, `required_alt_title` |
 *
 * </details>
 *
 * <details>
 * <summary>Single link (<code>link</code>)</summary>
 *
 * | Property                       | Value                       |
 * | ------------------------------ | --------------------------- |
 * | Code                           | `link`                      |
 * | Built-in editors for the field | `link_select`, `link_embed` |
 * | Default `editor`               | `link_select`               |
 * | Required validators            | `item_item_type`            |
 * | Other validators available     | `required`, `unique`        |
 *
 * </details>
 *
 * <details>
 * <summary>Multiple links (<code>links</code>)</summary>
 *
 * | Property                       | Value                         |
 * | ------------------------------ | ----------------------------- |
 * | Code                           | `links`                       |
 * | Built-in editors for the field | `links_select`, `links_embed` |
 * | Default `editor`               | `links_select`                |
 * | Required validators            | `items_item_type`             |
 * | Other validators available     | `size`                        |
 *
 * </details>
 *
 * <details>
 * <summary>Modular content (<code>rich_text</code>)</summary>
 *
 * | Property                       | Value              |
 * | ------------------------------ | ------------------ |
 * | Code                           | `rich_text`        |
 * | Built-in editors for the field | `rich_text`        |
 * | Required validators            | `rich_text_blocks` |
 * | Other validators available     | `size`             |
 *
 * </details>
 *
 * <details>
 * <summary>Structured text (<code>structured_text</code>)</summary>
 *
 * | Property                       | Value                                             |
 * | ------------------------------ | ------------------------------------------------- |
 * | Code                           | `structured_text`                                 |
 * | Built-in editors for the field | `structured_text`                                 |
 * | Required validators            | `structured_text_blocks`, `structured_text_links` |
 * | Other validators available     | `length`                                          |
 *
 * </details>
 *
 * ### Validators
 *
 * <details>
 * <summary><code>date_range</code></summary>
 *
 * Accept dates only inside a specified date range.
 *
 * | Parameter | Type          | Required | Description  |
 * | --------- | ------------- | -------- | ------------ |
 * | `min`     | ISO 8601 date |          | Minimum date |
 * | `max`     | ISO 8601 date |          | Maximum date |
 *
 * At least one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>date_time_range</code></summary>
 *
 * Accept date times only inside a specified date range.
 *
 * | Parameter | Type              | Required | Description      |
 * | --------- | ----------------- | -------- | ---------------- |
 * | `min`     | ISO 8601 datetime |          | Minimum datetime |
 * | `max`     | ISO 8601 datetime |          | Maximum datetime |
 *
 * At least one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>enum</code></summary>
 *
 * Only accept a specific set of values
 *
 * | Parameter | Type            | Required | Description           |
 * | --------- | --------------- | -------- | --------------------- |
 * | `values`  | `Array<String>` | ✅       | Set of allowed values |
 *
 * </details>
 *
 * <details>
 * <summary><code>extension</code></summary>
 *
 * Only accept assets with specific file extensions.
 *
 * | Parameter         | Type                                      | Required | Description                    |
 * | ----------------- | ----------------------------------------- | -------- | ------------------------------ |
 * | `extensions`      | `Array<String>`                           |          | Set of allowed file extensions |
 * | `predefined_list` | one of `"image"`, `"transformable_image"`, `"video"`, `"document"` |          | Allowed file type              |
 *
 * Only one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>file_size</code></summary>
 *
 * Accept assets only inside a specified date range.
 *
 * | Parameter   | Type                         | Required | Description                        |
 * | ----------- | ---------------------------- | -------- | ---------------------------------- |
 * | `min_value` | `Integer`                    |          | Numeric value for minimum filesize |
 * | `min_unit`  | one of `"B"`, `"KB"`, `"MB"` |          | Unit for minimum filesize          |
 * | `max_value` | `Integer`                    |          | Numeric value for maximum filesize |
 * | `max_unit`  | one of `"B"`, `"KB"`, `"MB"` |          | Unit for maximum filesize          |
 *
 * At least one couple of value/unit must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>format</code></summary>
 *
 * Only accept strings having a specific format.
 *
 * | Parameter            | Type                      | Required | Description                        |
 * | -------------------- | ------------------------- | -------- | ---------------------------------- |
 * | `custom_pattern`     | `Regexp`                  |          | Regular expression to be validated |
 * | `predefined_pattern` | one of `"email"`, `"url"` |          | Allowed format                     |
 *
 * Only one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>slug_format</code></summary>
 *
 * Only accept slugs having a specific format.
 *
 * | Parameter            | Type             | Required | Description                        |
 * | -------------------- | ---------------- | -------- | ---------------------------------- |
 * | `custom_pattern`     | `Regexp`         |          | Regular expression to be validated |
 * | `predefined_pattern` | `"webpage_slug"` |          | Allowed format                     |
 *
 * Only one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>image_dimensions</code></summary>
 *
 * Accept assets only within a specified height/width range.
 *
 * | Parameter          | Type      | Required | Description                      |
 * | ------------------ | --------- | -------- | -------------------------------- |
 * | `width_min_value`  | `Integer` |          | Numeric value for minimum width  |
 * | `width_max_value`  | `Integer` |          | Numeric value for maximum height |
 * | `height_min_value` | `Integer` |          | Numeric value for minimum width  |
 * | `height_max_value` | `Integer` |          | Numeric value for maximum height |
 *
 * At least one parameter must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>item_item_type</code></summary>
 *
 * Only accept references to records of the specified models.
 *
 * | Parameter                                         | Type                                                                     | Required | Description                                                                                         |
 * | ------------------------------------------------- | ------------------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------- |
 * | `item_types`                                      | `Array<Model ID>`                                                        | ✅       | Set of allowed model IDs                                                                            |
 * | `on_publish_with_unpublished_references_strategy` | `"fail"`, `"publish_references"` (default value: `"fail"`)               |          | Strategy to apply when a publishing is requested and this field references some unpublished records |
 * | `on_reference_unpublish_strategy`                 | `"fail"`, `"unpublish"`, `"delete_references"` (default value: `"fail"`) |          | Strategy to apply when unpublishing is requested for a record referenced by this field              |
 * | `on_reference_delete_strategy`                    | `"fail"`, `"delete_references"` (default value: `"delete_references"`)   |          | Strategy to apply when deletion is requested for a record referenced by this field                  |
 *
 * Possible values for `on_publish_with_unpublished_references_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"publish_references"`: Publish also the referenced records
 *
 * Possible values for `on_reference_unpublish_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"unpublish"`: Unpublish also this record
 * - `"delete_references"`: Try to remove the reference to the unpublished record (if the field has a `required` validation it will fail)
 *
 * Possible values for `on_reference_delete_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"delete_references"`: Try to remove the reference to the deleted record (if the field has a `required` validation it will fail)
 * </details>
 *
 * <details>
 * <summary><code>items_item_type</code></summary>
 *
 * Only accept references to records of the specified models.
 *
 * | Parameter                                         | Type                                                                     | Required | Description                                                                                         |
 * | ------------------------------------------------- | ------------------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------- |
 * | `item_types`                                      | `Array<Model ID>`                                                        | ✅       | Set of allowed model IDs                                                                            |
 * | `on_publish_with_unpublished_references_strategy` | `"fail"`, `"publish_references"` (default value: `"fail"`)               |          | Strategy to apply when a publishing is requested and this field references some unpublished records |
 * | `on_reference_unpublish_strategy`                 | `"fail"`, `"unpublish"`, `"delete_references"` (default value: `"fail"`) |          | Strategy to apply when unpublishing is requested for a record referenced by this field              |
 * | `on_reference_delete_strategy`                    | `"fail"`, `"delete_references"` (default value: `"delete_references"`)   |          | Strategy to apply when deletion is requested for a record referenced by this field                  |
 *
 * Possible values for `on_publish_with_unpublished_references_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"publish_references"`: Publish also the referenced records
 *
 * Possible values for `on_reference_unpublish_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"unpublish"`: Unpublish also this record
 * - `"delete_references"`: Try to remove the reference to the unpublished record (if the field has a `required` validation it will fail)
 *
 * Possible values for `on_reference_delete_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"delete_references"`: Try to remove the reference to the deleted record (if the field has a `required` validation it will fail)
 * </details>
 *
 * <details>
 * <summary><code>length</code></summary>
 *
 * Accept strings only with a specified number of characters.
 *
 * | Parameter | Type      | Required | Description     |
 * | --------- | --------- | -------- | --------------- |
 * | `min`     | `Integer` |          | Minimum length  |
 * | `eq`      | `Integer` |          | Expected length |
 * | `max`     | `Integer` |          | Maximum length  |
 *
 * At least one parameter must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>number_range</code></summary>
 *
 * Accept numbers only inside a specified range.
 *
 * | Parameter | Type    | Required | Description   |
 * | --------- | ------- | -------- | ------------- |
 * | `min`     | `Float` |          | Minimum value |
 * | `max`     | `Float` |          | Maximum value |
 *
 * At least one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>required</code></summary>
 *
 * Value must be specified or it won't be valid.
 *
 * </details>
 *
 * <details>
 * <summary><code>required_alt_title</code></summary>
 *
 * Assets contained in the field are required to specify custom title or alternate text, or they won't be valid.
 *
 * | Parameter | Type      | Required | Description                                                |
 * | --------- | --------- | -------- | ---------------------------------------------------------- |
 * | `title`   | `Boolean` |          | Whether the title for the asset must be specified          |
 * | `alt`     | `Boolean` |          | Whether the alternate text for the asset must be specified |
 *
 * At least one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>required_seo_fields</code></summary>
 *
 * SEO field is to specify one or more properties, or it won't be valid.
 *
 * | Parameter      | Type      | Required | Description                                        |
 * | -------------- | --------- | -------- | -------------------------------------------------- |
 * | `title`        | `Boolean` |          | Whether the meta title must be specified           |
 * | `description`  | `Boolean` |          | Whether the meta description must be specified     |
 * | `image`        | `Boolean` |          | Whether the social sharing image must be specified |
 * | `twitter_card` | `Boolean` |          | Whether the type of Twitter card must be specified |
 *
 * At least one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>title_length</code></summary>
 *
 * Limits the length of the title for a SEO field. Search engines usually truncate title tags to 60 character so it is a good practice to keep the title around this length.
 *
 * | Parameter | Type      | Required | Description   |
 * | --------- | --------- | -------- | ------------- |
 * | `min`     | `Integer` |          | Minimum value |
 * | `max`     | `Integer` |          | Maximum value |
 *
 * At least one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>description_length</code></summary>
 *
 * Limits the length of the description for a SEO field. Search engines usually truncate description tags to 160 character so it is a good practice to keep the description around this length.
 *
 * | Parameter | Type      | Required | Description   |
 * | --------- | --------- | -------- | ------------- |
 * | `min`     | `Integer` |          | Minimum value |
 * | `max`     | `Integer` |          | Maximum value |
 *
 * At least one of the parameters must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>rich_text_blocks</code></summary>
 *
 * Only accept references to block records of the specified block models.
 *
 * | Parameter    | Type                    | Required | Description                    |
 * | ------------ | ----------------------- | -------- | ------------------------------ |
 * | `item_types` | `Array<Block Model ID>` | ✅       | Set of allowed Block Model IDs |
 *
 * </details>
 *
 * <details>
 * <summary><code>structured_text_blocks</code></summary>
 *
 * Only accept references to block records of the specified block models.
 *
 * | Parameter    | Type                    | Required | Description                    |
 * | ------------ | ----------------------- | -------- | ------------------------------ |
 * | `item_types` | `Array<Block Model ID>` | ✅       | Set of allowed Block Model IDs |
 *
 * </details>
 *
 * <details>
 * <summary><code>structured_text_links</code></summary>
 *
 * Only accept `itemLink` to `inlineItem` nodes for records of the specified models.
 *
 * | Parameter                                         | Type                                                                                  | Required | Description                                                                                         |
 * | ------------------------------------------------- | ------------------------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------- |
 * | `item_types`                                      | `Array<Model ID>`                                                                     | ✅       | Set of allowed model IDs                                                                            |
 * | `on_publish_with_unpublished_references_strategy` | `"fail"`, `"publish_references"` (default value: `"fail"`)                            |          | Strategy to apply when a publishing is requested and this field references some unpublished records |
 * | `on_reference_unpublish_strategy`                 | `"fail"`, `"unpublish"`, `"delete_references"` (default value: `"delete_references"`) |          | Strategy to apply when unpublishing is requested for a record referenced by this field              |
 * | `on_reference_delete_strategy`                    | `"fail"`, `"delete_references"` (default value: `"delete_references"`)                |          | Strategy to apply when deletion is requested for a record referenced by this field                  |
 *
 * Possible values for `on_publish_with_unpublished_references_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"publish_references"`: Publish also the referenced records
 *
 * Possible values for `on_reference_unpublish_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"unpublish"`: Unpublish also this record
 * - `"delete_references"`: Try to remove the reference to the unpublished record (if the field has a `required` validation it will fail)
 *
 * Possible values for `on_reference_delete_strategy`:
 *
 * - `"fail"`: Fail the operation and notify the user
 * - `"delete_references"`: Try to remove the reference to the deleted record (if the field has a `required` validation it will fail)
 * </details>
 *
 * <details>
 * <summary><code>size</code></summary>
 *
 * Only accept a number of items within the specified range.
 *
 * | Parameter     | Type      | Required | Description                                        |
 * | ------------- | --------- | -------- | -------------------------------------------------- |
 * | `min`         | `Integer` |          | Minimum length                                     |
 * | `eq`          | `Integer` |          | Expected length                                    |
 * | `max`         | `Integer` |          | Maximum length                                     |
 * | `multiple_of` | `Integer` |          | The number of items must be multiple of this value |
 *
 * At least one parameter must be specified.
 *
 * </details>
 *
 * <details>
 * <summary><code>slug_title_field</code></summary>
 *
 * Specifies the ID of the _Single-line string_ field that will be used to generate the slug
 *
 * | Parameter        | Type       | Required | Description                                      |
 * | ---------------- | ---------- | -------- | ------------------------------------------------ |
 * | `title_field_id` | `Field ID` | ✅       | The field that will be used to generate the slug |
 *
 * </details>
 *
 * <details>
 * <summary><code>unique</code></summary>
 *
 * The value must be unique across the whole collection of records.
 *
 * </details>
 *
 * ### Configuration parameters for DatoCMS built-in field editors
 *
 * If a field editor is not specified in this table, just pass an empty object `{}` as its configuration parameters.
 *
 * <details>
 * <summary><code>boolean_radio_group</code></summary>
 *
 * Radio group input for _boolean_ fields.
 *
 * | Parameter        | Type                               | Required | Description                               |
 * | ---------------- | ---------------------------------- | -------- | ----------------------------------------- |
 * | `positive_radio` | `{ label: string, hint?: string }` | ✅       | Radio input for positive choice (`true`)  |
 * | `negative_radio` | `{ label: string, hint?: string }` | ✅       | Radio input for negative choice (`false`) |
 *
 * </details>
 *
 * <details>
 * <summary><code>string_radio_group</code></summary>
 *
 * Radio group input for _string_ fields.
 *
 * | Parameter | Type                                                     | Required | Description                 |
 * | --------- | -------------------------------------------------------- | -------- | --------------------------- |
 * | `radios`  | `Array<{ label: string, value: string, hint?: string }>` | ✅       | The different radio options |
 *
 * </details>
 *
 * <details>
 * <summary><code>string_select</code></summary>
 *
 * Select input for _string_ fields.
 *
 * | Parameter | Type                                                     | Required | Description                  |
 * | --------- | -------------------------------------------------------- | -------- | ---------------------------- |
 * | `options` | `Array<{ label: string, value: string, hint?: string }>` | ✅       | The different select options |
 *
 * </details>
 *
 * <details>
 * <summary><code>string_multi_select</code></summary>
 *
 * Select input for _JSON_ fields, to edit an array of strings.
 *
 * | Parameter | Type                                                     | Required | Description                  |
 * | --------- | -------------------------------------------------------- | -------- | ---------------------------- |
 * | `options` | `Array<{ label: string, value: string, hint?: string }>` | ✅       | The different select options |
 *
 * </details>
 *
 * <details>
 * <summary><code>string_checkbox_group</code></summary>
 *
 * Multiple chechboxes input for _JSON_ fields, to edit an array of strings.
 *
 * | Parameter | Type                                                     | Required | Description                  |
 * | --------- | -------------------------------------------------------- | -------- | ---------------------------- |
 * | `options` | `Array<{ label: string, value: string, hint?: string }>` | ✅       | The different select options |
 *
 * </details>
 *
 * <details>
 * <summary><code>single_line</code></summary>
 *
 * Simple textual input for _Single-line string_ fields.
 *
 * | Parameter | Type      | Required | Description                                                                      |
 * | --------- | --------- | -------- | -------------------------------------------------------------------------------- |
 * | `heading` | `Boolean` | ✅       | Indicates if the field should be shown bigger, as a field representing a heading |
 *
 * </details>
 *
 * <details>
 * <summary><code>markdown</code></summary>
 *
 * Markdown editor for _Multiple-paragraph text_ fields.
 *
 * | Parameter | Type            | Required | Description                                                                                                                                                                                                       |
 * | --------- | --------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | `toolbar` | `Array<String>` | ✅       | Specify which buttons the toolbar should have. Valid values: `"heading"`, `"bold"`, `"italic"`, `"strikethrough"`, `"code"`, `"unordered_list"`, `"ordered_list"`, `"quote"`, `"link"`, `"image"`, `"fullscreen"` |
 *
 * </details>
 *
 * <details>
 * <summary><code>wysiwyg</code></summary>
 *
 * HTML editor for _Multiple-paragraph text_ fields.
 *
 * | Parameter | Type            | Required | Description                                                                                                                                                                                                                                                                                                                                                     |
 * | --------- | --------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | `toolbar` | `Array<String>` | ✅       | Specify which buttons the toolbar should have. Valid values: `"format"`, `"bold"`, `"italic"`, `"strikethrough"`, `"code"`, `"ordered_list"`, `"unordered_list"`, `"quote"`, `"table"`, `"link"`, `"image"`, `"show_source"`, `"undo"`, `"redo"`, `"align_left"`, `"align_center"`, `"align_right"`, `"align_justify"`, `"outdent"`, `"indent"`, `"fullscreen"` |
 *
 * </details>
 *
 * <details>
 * <summary><code>textarea</code></summary>
 *
 * Basic textarea editor for _Multiple-paragraph text_ fields.
 *
 * </details>
 *
 * <details>
 * <summary><code>color_picker</code></summary>
 *
 * Built-in editor for _Color_ fields.
 *
 * | Parameter       | Type                      | Required | Description                                               |
 * | --------------- | ------------------------- | -------- | --------------------------------------------------------- |
 * | `enable_alpha`  | `Boolean`                 | ✅       | Should the color picker allow to specify the alpha value? |
 * | `preset_colors` | `Array<Hex color string>` | ✅       | List of preset colors to offer to the user                |
 *
 * </details>
 *
 * <details>
 * <summary><code>slug</code></summary>
 *
 * Built-in editor for _Slug_ fields.
 *
 * | Parameter    | Type     | Required | Description                                                                            |
 * | ------------ | -------- | -------- | -------------------------------------------------------------------------------------- |
 * | `url_prefix` | `String` |          | A prefix that will be shown in the editor's form to give some context to your editors. |
 *
 * </details>
 *
 * <details>
 * <summary><code>rich_text</code></summary>
 *
 * Built-in editor for _Modular content_ fields.
 *
 * | Parameter         | Type      | Required | Description                                                |
 * | ----------------- | --------- | -------- | ---------------------------------------------------------- |
 * | `start_collapsed` | `Boolean` |          | Whether you want block records collapsed by default or not |
 *
 * </details>
 *
 * <details>
 * <summary><code>structured_text</code></summary>
 *
 * Built-in editor for _Structured text_ fields.
 *
 * | Parameter                 | Type            | Required | Description                                                                                                                                   |
 * | ------------------------- | --------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
 * | `nodes`                   | `Array<String>` | ✅       | Specify which nodes the field should allow. Valid values: `"blockquote"`, `"code"`, `"heading"`, `"link"`, `"list"`, `"thematicBreak"`        |
 * | `marks`                   | `Array<String>` | ✅       | Specify which marks the field should allow. Valid values: `"strong"`, `"emphasis"`, `"underline"`, `"strikethrough"`, `"code"`, `"highlight"` |
 * | `blocks_start_collapsed`  | `Boolean`       |          | Whether you want block nodes collapsed by default or not                                                                                      |
 * | `show_links_target_blank` | `Boolean`       |          | Whether you want to show the "Open this link in a new tab?" checkbox, that fills in the `target: "_blank"` meta attribute for links           |
 * | `show_links_meta_editor`  | `Boolean`       |          | Whether you want to show the complete meta editor for links                                                                                   |
 *
 * </details>
 *
 * <details>
 * <summary><code>link_select</code> and <code>links_select</code></summary>
 *
 * Use a select input with auto-completion to pick the records to reference inside the field.
 *
 * </details>
 *
 * <details>
 * <summary><code>link_embed</code> and <code>links_embed</code></summary>
 *
 * Use an expanded view with records' image preview to pick the records to reference inside the field.
 *
 * </details>
 *
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "field".
 */
export declare type Field = {
    id: FieldIdentity;
    type: FieldType;
    /**
     * The label of the field
     */
    label: string;
    /**
     * Type of input
     */
    field_type: string;
    /**
     * Whether the field needs to be multilanguage or not
     */
    localized: boolean;
    /**
     * Default value for Field. When field is localized accepts an object of default values with site locales as keys
     */
    default_value: boolean | null | string | number | {
        [k: string]: unknown;
    };
    /**
     * Field API key
     */
    api_key: string;
    /**
     * Field hint
     */
    hint: string | null;
    /**
     * Optional field validations
     */
    validators: {
        [k: string]: unknown;
    };
    /**
     * Field appearance
     */
    appeareance: {
        editor: string;
        parameters: {
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * Field appearance details, plugin configuration and field add-ons
     */
    appearance: {
        /**
         * A valid editor can be a DatoCMS default field editor type (ie. `"single_line"`), or a plugin ID offering a custom field editor
         */
        editor: string;
        /**
         * The specific field extension to use for the field (only if the editor is a modern plugin)
         */
        field_extension?: string;
        /**
         * The editor plugin's parameters
         */
        parameters: {
            [k: string]: unknown;
        };
        /**
         * An array of add-on plugins with id and parameters
         */
        addons: {
            /**
             * The ID of a plugin offering a field addon
             */
            id: string;
            /**
             * The specific field extension to use for the field (only if the editor is a modern plugin)
             */
            field_extension?: string;
            parameters: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        }[];
        [k: string]: unknown;
    };
    /**
     * Ordering index
     */
    position: number;
    item_type: ItemTypeData;
    fieldset: null | FieldsetData;
};
export declare type FieldCreateJobSchema = Field;
export declare type FieldUpdateJobSchema = Field;
export declare type FieldSelfTargetSchema = Field;
export declare type FieldDestroyJobSchema = Field;
export declare type FieldDuplicateJobSchema = Field;
/**
 * JSON API attributes
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type FieldAttributes = {
    /**
     * The label of the field
     */
    label: string;
    /**
     * Type of input
     */
    field_type: string;
    /**
     * Whether the field needs to be multilanguage or not
     */
    localized: boolean;
    /**
     * Default value for Field. When field is localized accepts an object of default values with site locales as keys
     */
    default_value: boolean | null | string | number | {
        [k: string]: unknown;
    };
    /**
     * Field API key
     */
    api_key: string;
    /**
     * Field hint
     */
    hint: string | null;
    /**
     * Optional field validations
     */
    validators: {
        [k: string]: unknown;
    };
    /**
     * Field appearance
     */
    appeareance: {
        editor: string;
        parameters: {
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * Field appearance details, plugin configuration and field add-ons
     */
    appearance: {
        /**
         * A valid editor can be a DatoCMS default field editor type (ie. `"single_line"`), or a plugin ID offering a custom field editor
         */
        editor: string;
        /**
         * The specific field extension to use for the field (only if the editor is a modern plugin)
         */
        field_extension?: string;
        /**
         * The editor plugin's parameters
         */
        parameters: {
            [k: string]: unknown;
        };
        /**
         * An array of add-on plugins with id and parameters
         */
        addons: {
            /**
             * The ID of a plugin offering a field addon
             */
            id: string;
            /**
             * The specific field extension to use for the field (only if the editor is a modern plugin)
             */
            field_extension?: string;
            parameters: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        }[];
        [k: string]: unknown;
    };
    /**
     * Ordering index
     */
    position: number;
};
/**
 * JSON API links
 *
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type FieldRelationships = {
    item_type: ItemTypeData;
    fieldset: null | FieldsetData;
};
/**
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type FieldCreateSchema = {
    type?: FieldType;
    /**
     * The label of the field
     */
    label: string;
    /**
     * Type of input
     */
    field_type: string;
    /**
     * Field API key
     */
    api_key: string;
    /**
     * Whether the field needs to be multilanguage or not
     */
    localized?: boolean;
    /**
     * Optional field validations
     */
    validators?: {
        [k: string]: unknown;
    };
    /**
     * Field appearance
     */
    appeareance?: {
        editor: string;
        parameters: {
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * Field appearance details, plugin configuration and field add-ons
     */
    appearance?: {
        /**
         * A valid editor can be a DatoCMS default field editor type (ie. `"single_line"`), or a plugin ID offering a custom field editor
         */
        editor: string;
        /**
         * The specific field extension to use for the field (only if the editor is a modern plugin)
         */
        field_extension?: string;
        /**
         * The editor plugin's parameters
         */
        parameters: {
            [k: string]: unknown;
        };
        /**
         * An array of add-on plugins with id and parameters
         */
        addons: {
            /**
             * The ID of a plugin offering a field addon
             */
            id: string;
            /**
             * The specific field extension to use for the field (only if the editor is a modern plugin)
             */
            field_extension?: string;
            parameters: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        }[];
        [k: string]: unknown;
    };
    /**
     * Ordering index
     */
    position?: number;
    /**
     * Field hint
     */
    hint?: string | null;
    /**
     * Default value for Field. When field is localized accepts an object of default values with site locales as keys
     */
    default_value?: boolean | null | string | number | {
        [k: string]: unknown;
    };
    fieldset?: null | FieldsetData;
};
/**
 * This interface was referenced by `Field`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type FieldUpdateSchema = {
    id?: FieldIdentity;
    type?: FieldType;
    /**
     * Default value for Field. When field is localized accepts an object of default values with site locales as keys
     */
    default_value?: boolean | null | string | number | {
        [k: string]: unknown;
    };
    /**
     * The label of the field
     */
    label?: string;
    /**
     * Field API key
     */
    api_key?: string;
    /**
     * Whether the field needs to be multilanguage or not
     */
    localized?: boolean;
    /**
     * Optional field validations
     */
    validators?: {
        [k: string]: unknown;
    };
    /**
     * Field appearance
     */
    appeareance?: {
        editor: string;
        parameters: {
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * Field appearance details, plugin configuration and field add-ons
     */
    appearance?: {
        /**
         * A valid editor can be a DatoCMS default field editor type (ie. `"single_line"`), or a plugin ID offering a custom field editor
         */
        editor: string;
        /**
         * The specific field extension to use for the field (only if the editor is a modern plugin)
         */
        field_extension?: string;
        /**
         * The editor plugin's parameters
         */
        parameters: {
            [k: string]: unknown;
        };
        /**
         * An array of add-on plugins with id and parameters
         */
        addons: {
            /**
             * The ID of a plugin offering a field addon
             */
            id: string;
            /**
             * The specific field extension to use for the field (only if the editor is a modern plugin)
             */
            field_extension?: string;
            parameters: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        }[];
        [k: string]: unknown;
    };
    /**
     * Ordering index
     */
    position?: number;
    /**
     * Type of input
     */
    field_type?: string;
    /**
     * Field hint
     */
    hint?: string | null;
    fieldset?: null | FieldsetData;
};
/**
 * Fields can be organized and grouped into fieldset to better present them to editors.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "fieldset".
 */
export declare type Fieldset = {
    id: FieldsetIdentity;
    type: FieldsetType;
    /**
     * The title of the fieldset
     */
    title: string;
    /**
     * Description/contextual hint for the fieldset
     */
    hint: string | null;
    /**
     * Whether the fieldset can be collapsed or not
     */
    collapsible: boolean;
    /**
     * When fieldset is collapsible, determines if the default is to start collapsed or not
     */
    start_collapsed: boolean;
    /**
     * Ordering index
     */
    position: number;
    item_type: ItemTypeData;
};
export declare type FieldsetCreateTargetSchema = Fieldset;
export declare type FieldsetUpdateTargetSchema = Fieldset;
export declare type FieldsetSelfTargetSchema = Fieldset;
export declare type FieldsetDestroyTargetSchema = Fieldset;
/**
 * JSON API attributes
 *
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type FieldsetAttributes = {
    /**
     * The title of the fieldset
     */
    title: string;
    /**
     * Description/contextual hint for the fieldset
     */
    hint: string | null;
    /**
     * Whether the fieldset can be collapsed or not
     */
    collapsible: boolean;
    /**
     * When fieldset is collapsible, determines if the default is to start collapsed or not
     */
    start_collapsed: boolean;
    /**
     * Ordering index
     */
    position: number;
};
/**
 * JSON API links
 *
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type FieldsetRelationships = {
    item_type: ItemTypeData;
};
/**
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type FieldsetCreateSchema = {
    type?: FieldsetType;
    /**
     * The title of the fieldset
     */
    title: string;
    /**
     * Description/contextual hint for the fieldset
     */
    hint?: string | null;
    /**
     * Ordering index
     */
    position?: number;
    /**
     * Whether the fieldset can be collapsed or not
     */
    collapsible?: boolean;
    /**
     * When fieldset is collapsible, determines if the default is to start collapsed or not
     */
    start_collapsed?: boolean;
};
/**
 * This interface was referenced by `Fieldset`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type FieldsetUpdateSchema = {
    id?: FieldsetIdentity;
    type?: FieldsetType;
    /**
     * The title of the fieldset
     */
    title?: string;
    /**
     * Description/contextual hint for the fieldset
     */
    hint?: string | null;
    /**
     * Ordering index
     */
    position?: number;
    /**
     * Whether the fieldset can be collapsed or not
     */
    collapsible?: boolean;
    /**
     * When fieldset is collapsible, determines if the default is to start collapsed or not
     */
    start_collapsed?: boolean;
};
/**
 * A session is required to access to read-and-write API endpoints
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "session".
 */
export declare type Session = {
    id: SessionIdentity;
    type: SessionType;
    user: UserData;
};
export declare type SessionCreateTargetSchema = Session;
/**
 * JSON API data
 *
 * This interface was referenced by `Session`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SessionData = {
    type: SessionType;
    id: SessionIdentity;
};
/**
 * JSON API links
 *
 * This interface was referenced by `Session`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type SessionRelationships = {
    user: UserData;
};
/**
 * This interface was referenced by `Session`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type SessionCreateSchema = {
    /**
     * JSON API type field
     */
    type?: 'email_credentials';
    /**
     * Email
     */
    email: string;
    /**
     * Password
     */
    password: string;
    /**
     * Two-factor authentication one-time password
     */
    otp_code?: string;
};
/**
 * Plugins enable developers to replace DatoCMS field components with HTML5 applications so the editing experiences of the DatoCMS web app can be customized.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "plugin".
 */
export declare type Plugin = {
    id: PluginIdentity;
    type: PluginType;
    /**
     * The name of the plugin
     */
    name: string;
    /**
     * A description of the plugin
     */
    description: null | string;
    /**
     * NPM package name of the plugin (or null if it's a private plugin)
     */
    package_name: null | string;
    /**
     * The installed version of the plugin (or null if it's a private plugin)
     */
    package_version: null | string;
    /**
     * The entry point URL of the plugin
     */
    url: string;
    /**
     * Global plugin configuration. Plugins can persist whatever information they want in this object to reuse it later.
     */
    parameters: {
        [k: string]: unknown;
    };
    /**
     * Permissions granted to this plugin
     */
    permissions: 'currentUserAccessToken'[];
    /**
     * The type of field extension a legacy plugin implements
     */
    plugin_type: 'field_editor' | 'sidebar' | 'field_addon' | null;
    /**
     * On which types of field in which a legacy plugin can be used
     */
    field_types: null | ('boolean' | 'date' | 'date_time' | 'float' | 'integer' | 'string' | 'text' | 'lat_lon' | 'json' | 'seo' | 'link' | 'links' | 'video' | 'color' | 'slug' | 'rich_text' | 'file' | 'gallery')[];
    /**
     * The schema for the parameters a legacy plugin can persist
     */
    parameter_definitions: null | {
        global: unknown[];
        instance: unknown[];
    };
    meta: PluginMeta;
};
export declare type PluginCreateTargetSchema = Plugin;
export declare type PluginUpdateTargetSchema = Plugin;
export declare type PluginSelfTargetSchema = Plugin;
export declare type PluginDestroyTargetSchema = Plugin;
/**
 * JSON API meta
 *
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type PluginMeta = {
    /**
     * Version of the plugin. Legacy plugins are v1, new plugins are v2
     */
    version: string;
};
/**
 * JSON API data
 *
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type PluginData = {
    type: PluginType;
    id: PluginIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type PluginAttributes = {
    /**
     * The name of the plugin
     */
    name: string;
    /**
     * A description of the plugin
     */
    description: null | string;
    /**
     * NPM package name of the plugin (or null if it's a private plugin)
     */
    package_name: null | string;
    /**
     * The installed version of the plugin (or null if it's a private plugin)
     */
    package_version: null | string;
    /**
     * The entry point URL of the plugin
     */
    url: string;
    /**
     * Global plugin configuration. Plugins can persist whatever information they want in this object to reuse it later.
     */
    parameters: {
        [k: string]: unknown;
    };
    /**
     * Permissions granted to this plugin
     */
    permissions: 'currentUserAccessToken'[];
    /**
     * The type of field extension a legacy plugin implements
     */
    plugin_type: 'field_editor' | 'sidebar' | 'field_addon' | null;
    /**
     * On which types of field in which a legacy plugin can be used
     */
    field_types: null | ('boolean' | 'date' | 'date_time' | 'float' | 'integer' | 'string' | 'text' | 'lat_lon' | 'json' | 'seo' | 'link' | 'links' | 'video' | 'color' | 'slug' | 'rich_text' | 'file' | 'gallery')[];
    /**
     * The schema for the parameters a legacy plugin can persist
     */
    parameter_definitions: null | {
        global: unknown[];
        instance: unknown[];
    };
};
/**
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type PluginCreateSchema = {
    type?: PluginType;
    /**
     * NPM package name of the public plugin you want to install. For public plugins, that's the only attribute you need to pass.
     */
    package_name?: null | string;
    /**
     * The name of the plugin. Only to be passed if package name key is not specified.
     */
    name?: string;
    /**
     * A description of the plugin. Only to be passed if package name key is not specified.
     */
    description?: null | string;
    /**
     * The entry point URL of the plugin. Only to be passed if package name key is not specified.
     */
    url?: string;
    /**
     * Permissions granted to this plugin. Only to be passed if package name key is not specified.
     */
    permissions?: 'currentUserAccessToken'[];
    /**
     * The type of field extension this legacy plugin implements. Only to be passed if package name key is not specified.
     */
    plugin_type?: 'field_editor' | 'sidebar' | 'field_addon';
    /**
     * On which types of field in which this legacy plugin can be used. Only to be passed if package name key is not specified.
     */
    field_types?: ('boolean' | 'date' | 'date_time' | 'float' | 'integer' | 'string' | 'text' | 'lat_lon' | 'json' | 'seo' | 'link' | 'links' | 'video' | 'color' | 'slug' | 'rich_text' | 'file' | 'gallery')[];
    /**
     * The schema for the parameters this legacy plugin can persist
     */
    parameter_definitions?: {
        global: unknown[];
        instance: unknown[];
    };
    /**
     * NPM version of the plugin
     */
    package_version?: null | string;
};
/**
 * This interface was referenced by `Plugin`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type PluginUpdateSchema = {
    id?: PluginIdentity;
    type?: PluginType;
    /**
     * The name of the plugin
     */
    name?: string;
    /**
     * A description of the plugin
     */
    description?: null | string;
    /**
     * The entry point URL of the plugin
     */
    url?: string;
    /**
     * Global plugin configuration. Plugins can persist whatever information they want in this object to reuse it later.
     */
    parameters?: {
        [k: string]: unknown;
    };
    /**
     * The installed version of the plugin (or null if it's a private plugin)
     */
    package_version?: null | string;
    /**
     * Permissions granted to this plugin
     */
    permissions?: 'currentUserAccessToken'[];
    meta?: {
        [k: string]: unknown;
    };
};
/**
 * Some API endpoint give results asynchronously, returning the ID of a job.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "job_result".
 */
export declare type JobResult = {
    id: JobResultIdentity;
    type: JobResultType;
    /**
     * Status of delayed HTTP response
     */
    status: number;
    /**
     * JSON API response of the HTTP request
     */
    payload: null | {
        [k: string]: unknown;
    };
};
export declare type JobResultSelfTargetSchema = JobResult;
/**
 * JSON API data
 *
 * This interface was referenced by `JobResult`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type JobResultData = {
    type: JobResultType;
    id: JobResultIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `JobResult`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type JobResultAttributes = {
    /**
     * Status of delayed HTTP response
     */
    status: number;
    /**
     * JSON API response of the HTTP request
     */
    payload: null | {
        [k: string]: unknown;
    };
};
/**
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "subscription_limit".
 */
export declare type SubscriptionLimit = {
    id: SubscriptionLimitIdentity;
    type: SubscriptionLimitType;
    /**
     * The codename for the limit
     */
    code: string;
    /**
     * Current usage
     */
    usage: number;
    /**
     * The actual limit
     */
    limit: number | null;
};
export declare type SubscriptionLimitSelfTargetSchema = SubscriptionLimit;
/**
 * JSON API data
 *
 * This interface was referenced by `SubscriptionLimit`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SubscriptionLimitData = {
    type: SubscriptionLimitType;
    id: SubscriptionLimitIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `SubscriptionLimit`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SubscriptionLimitAttributes = {
    /**
     * The codename for the limit
     */
    code: string;
    /**
     * Current usage
     */
    usage: number;
    /**
     * The actual limit
     */
    limit: number | null;
};
/**
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "subscription_feature".
 */
export declare type SubscriptionFeature = {
    id: SubscriptionFeatureIdentity;
    type: SubscriptionFeatureType;
    /**
     * The codename for the feature
     */
    code: string;
    /**
     * Whether the project is currently using the feature
     */
    in_use?: boolean;
    /**
     * Whether the feature is available on the current project
     */
    enabled: boolean;
};
/**
 * JSON API data
 *
 * This interface was referenced by `SubscriptionFeature`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SubscriptionFeatureData = {
    type: SubscriptionFeatureType;
    id: SubscriptionFeatureIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `SubscriptionFeature`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SubscriptionFeatureAttributes = {
    /**
     * The codename for the feature
     */
    code: string;
    /**
     * Whether the project is currently using the feature
     */
    in_use?: boolean;
    /**
     * Whether the feature is available on the current project
     */
    enabled: boolean;
};
/**
 * Represents an event occurred during the deploy process of your administrative area.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "build_event".
 */
export declare type BuildEvent = {
    id: BuildEventIdentity;
    type: BuildEventType;
    /**
     * The type of activity
     */
    event_type: 'request_success' | 'request_failure' | 'response_success' | 'response_failure' | 'request_aborted' | 'response_unprocessable' | 'indexing_started' | 'indexing_success' | 'indexing_failure';
    /**
     * The moment the activity occurred
     */
    created_at: string;
    /**
     * Any details regarding the event
     */
    data: {
        [k: string]: unknown;
    };
    build_trigger: BuildTriggerData;
};
export declare type BuildEventSelfTargetSchema = BuildEvent;
/**
 * JSON API data
 *
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type BuildTriggerData = {
    type: BuildTriggerType;
    id: BuildTriggerIdentity;
};
/**
 * JSON API data
 *
 * This interface was referenced by `BuildEvent`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type BuildEventData = {
    type: BuildEventType;
    id: BuildEventIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `BuildEvent`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type BuildEventAttributes = {
    /**
     * The type of activity
     */
    event_type: 'request_success' | 'request_failure' | 'response_success' | 'response_failure' | 'request_aborted' | 'response_unprocessable' | 'indexing_started' | 'indexing_success' | 'indexing_failure';
    /**
     * The moment the activity occurred
     */
    created_at: string;
    /**
     * Any details regarding the event
     */
    data: {
        [k: string]: unknown;
    };
};
/**
 * JSON API links
 *
 * This interface was referenced by `BuildEvent`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type BuildEventRelationships = {
    build_trigger: BuildTriggerData;
};
/**
 * DatoCMS stores the individual pieces of content you create from a model as records, which are much like table rows in a database. For backward-compatibility reasons, the API refers to records as "items".
 *
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `destroy.targetSchema` link.
 *
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `destroy.targetSchema` link.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "item".
 */
export declare type Item = {
    id: ItemIdentity;
    type: ItemType1;
    item_type: ItemTypeData;
    creator?: AccountData | AccessTokenData | UserData | SsoUserData;
    meta: ItemMeta;
    [k: string]: unknown;
};
export declare type ItemCreateTargetSchema = Item;
export declare type ItemDuplicateJobSchema = Item;
export declare type ItemUpdateTargetSchema = Item;
export declare type ItemSelfTargetSchema = Item;
export declare type ItemDestroyJobSchema = Item;
export declare type ItemPublishTargetSchema = Item;
export declare type ItemUnpublishTargetSchema = Item;
export declare type ScheduledPublicationDestroyTargetSchema = Item;
export declare type ScheduledUnpublishingDestroyTargetSchema = Item;
/**
 * Meta information regarding the record
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type ItemMeta = {
    /**
     * Date of creation
     */
    created_at: string;
    /**
     * Last update time
     */
    updated_at: string;
    /**
     * Date of last publication
     */
    published_at: null | string;
    /**
     * Date of first publication
     */
    first_published_at: null | string;
    /**
     * Date of future publication
     */
    publication_scheduled_at: null | string;
    /**
     * Date of future unpublishing
     */
    unpublishing_scheduled_at: null | string;
    /**
     * Status
     */
    status: null | ('draft' | 'updated' | 'published');
    /**
     * Whether the current record is valid or not
     */
    is_valid: boolean;
    /**
     * The ID of the current record version
     */
    current_version: string;
    /**
     * Workflow stage in which the item is
     */
    stage: null | string;
};
/**
 * The JSON data associated to the record
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type ItemAttributes = {
    [k: string]: unknown;
};
/**
 * JSON API links
 *
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type ItemRelationships = {
    item_type: ItemTypeData;
    creator?: AccountData | AccessTokenData | UserData | SsoUserData;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `validate_existing.schema` link.
 */
export declare type ItemValidateExistingSchema = {
    id?: ItemIdentity;
    type?: ItemType1;
    item_type: ItemTypeData;
    creator?: AccountData | AccessTokenData | UserData | SsoUserData;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `validate_new.schema` link.
 */
export declare type ItemValidateNewSchema = {
    type?: ItemType1;
    item_type: ItemTypeData;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type ItemCreateSchema = {
    type?: ItemType1;
    item_type: ItemTypeData;
    /**
     * Meta information regarding the record
     */
    meta?: {
        /**
         * Date of creation
         */
        created_at?: string;
        /**
         * Last update time
         */
        updated_at?: string;
        /**
         * Date of last publication
         */
        published_at?: null | string;
        /**
         * Date of first publication
         */
        first_published_at?: null | string;
        /**
         * Date of future publication
         */
        publication_scheduled_at?: null | string;
        /**
         * Status
         */
        status?: null | ('draft' | 'updated' | 'published');
        /**
         * Whether the current record is valid or not
         */
        is_valid?: boolean;
        /**
         * The ID of the current record version
         */
        current_version?: string;
    };
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type ItemUpdateSchema = {
    id?: ItemIdentity;
    type?: ItemType1;
    item_type?: ItemTypeData;
    creator?: AccountData | AccessTokenData | UserData | SsoUserData;
    /**
     * Meta information regarding the record
     */
    meta?: {
        /**
         * Date of creation
         */
        created_at?: string;
        /**
         * Last update time
         */
        updated_at?: string;
        /**
         * Date of last publication
         */
        published_at?: null | string;
        /**
         * Date of first publication
         */
        first_published_at?: null | string;
        /**
         * Date of future publication
         */
        publication_scheduled_at?: null | string;
        /**
         * Date of future unpublishing
         */
        unpublishing_scheduled_at?: null | string;
        /**
         * Status
         */
        status?: null | ('draft' | 'updated' | 'published');
        /**
         * Whether the current record is valid or not
         */
        is_valid?: boolean;
        /**
         * The ID of the current record version (for optimistic locking, see the example)
         */
        current_version?: string;
        /**
         * The new stage to move the record to
         */
        stage?: string | null;
    };
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_publish.schema` link.
 */
export declare type ItemBulkPublishSchema = {
    /**
     * JSON API type field
     */
    type?: 'item_bulk_publish_operation';
    items: ItemData[];
    minItems?: unknown;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_unpublish.schema` link.
 */
export declare type ItemBulkUnpublishSchema = {
    /**
     * JSON API type field
     */
    type?: 'item_bulk_unpublish_operation';
    items: ItemData[];
    minItems?: unknown;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_destroy.schema` link.
 */
export declare type ItemBulkDestroySchema = {
    /**
     * JSON API type field
     */
    type?: 'item_bulk_destroy_operation';
    items: ItemData[];
    minItems?: unknown;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `Item`'s JSON-Schema
 * via the `bulk_move_to_stage.schema` link.
 */
export declare type ItemBulkMoveToStageSchema = {
    /**
     * JSON API type field
     */
    type?: 'item_bulk_move_to_stage_operation';
    /**
     * Stage to be moved to
     */
    stage: string;
    items: ItemData[];
    minItems?: unknown;
};
/**
 * Every change to a record is stored as a separate record version in DatoCMS.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "item_version".
 */
export declare type ItemVersion = {
    id: ItemVersionIdentity;
    type: ItemVersionType;
    item_type: ItemTypeData;
    item: ItemData;
    editor: AccountData | AccessTokenData | UserData | SsoUserData;
    meta: ItemVersionMeta;
    [k: string]: unknown;
};
export declare type ItemVersionSelfTargetSchema = ItemVersion;
/**
 * Meta information regarding the record version
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type ItemVersionMeta = {
    /**
     * Date of record version creation
     */
    created_at: string;
    /**
     * Whether the record version is valid or not
     */
    is_valid: boolean;
    /**
     * Whether the record version is the published version or not
     */
    is_published: boolean;
    /**
     * Whether the record version is the most recent version or not
     */
    is_current: boolean;
};
/**
 * JSON API data
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type ItemVersionData = {
    type: ItemVersionType;
    id: ItemVersionIdentity;
};
/**
 * The JSON data associated to the record version
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type ItemVersionAttributes = {
    [k: string]: unknown;
};
/**
 * JSON API links
 *
 * This interface was referenced by `ItemVersion`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type ItemVersionRelationships = {
    item_type: ItemTypeData;
    item: ItemData;
    editor: AccountData | AccessTokenData | UserData | SsoUserData;
};
/**
 * Every file you upload to DatoCMS will be retrievable from this endpoint.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "upload".
 */
export declare type Upload = {
    id: UploadIdentity;
    type: UploadType;
    /**
     * size of the upload
     */
    size: number;
    /**
     * Width of image
     */
    width: null | number;
    /**
     * Height of image
     */
    height: null | number;
    /**
     * Upload path
     */
    path: string;
    /**
     * Upload basename
     */
    basename: string;
    /**
     * Upload filename
     */
    filename: string;
    /**
     * Upload URL
     */
    url: string;
    /**
     * Format
     */
    format: string | null;
    /**
     * Author
     */
    author: string | null;
    /**
     * Copyright
     */
    copyright: string | null;
    /**
     * Notes
     */
    notes: string | null;
    /**
     * The MD5 hash of the asset
     */
    md5: string;
    /**
     * Seconds of duration for the video
     */
    duration: number | null;
    /**
     * Frame rate (FPS) for the video
     */
    frame_rate: number | null;
    /**
     * Blurhash for the asset
     */
    blurhash: string | null;
    /**
     * Public Mux playback ID. Used with stream.mux.com to create the source URL for a video player.
     */
    mux_playback_id: string | null;
    /**
     * Maximum quality of MP4 rendition available
     */
    mux_mp4_highest_res: null | 'high' | 'medium' | 'low';
    /**
     * For each of the project's locales, the default metadata to apply if nothing is specified at record's level.
     */
    default_field_metadata: {
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^(?<languagecode>[a-z]{0,3}(-[A-Za-z]+)?(-[A-Z]{0,3})?)$".
         */
        [k: string]: {
            /**
             * Alternate text for the asset
             */
            alt: string | null;
            /**
             * Title for the asset
             */
            title: string | null;
            /**
             * Object with arbitrary metadata
             */
            custom_data: {
                [k: string]: unknown;
            };
            /**
             * Focal point (only for image assets)
             */
            focal_point: {
                /**
                 * Horizontal position expressed as float between 0 and 1
                 */
                x: number;
                /**
                 * Vertical position expressed as float between 0 and 1
                 */
                y: number;
            } | null;
        };
    };
    /**
     * Is this upload an image?
     */
    is_image: boolean;
    /**
     * Date of upload
     */
    created_at: null | string;
    /**
     * Date of last update
     */
    updated_at: null | string;
    /**
     * Mime type of upload
     */
    mime_type: null | string;
    /**
     * Tags
     */
    tags: string[];
    /**
     * Smart tags
     */
    smart_tags: string[];
    /**
     * Exif information
     */
    exif_info: {
        [k: string]: unknown;
    };
    /**
     * Dominant colors of the image
     */
    colors: {
        /**
         * Red value (from 0 to 255)
         */
        red: number;
        /**
         * Green value (from 0 to 255)
         */
        green: number;
        /**
         * Blue value (from 0 to 255)
         */
        blue: number;
        /**
         * Alpha value (from 0 to 255)
         */
        alpha: number;
    }[];
    creator: AccountData | AccessTokenData | UserData | SsoUserData;
};
export declare type UploadCreateJobSchema = Upload;
export declare type UploadSelfTargetSchema = Upload;
export declare type UploadDestroyTargetSchema = Upload;
export declare type UploadUpdateJobSchema = Upload;
/**
 * JSON API data
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type UploadData = {
    type: UploadType;
    id: UploadIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type UploadAttributes = {
    /**
     * size of the upload
     */
    size: number;
    /**
     * Width of image
     */
    width: null | number;
    /**
     * Height of image
     */
    height: null | number;
    /**
     * Upload path
     */
    path: string;
    /**
     * Upload basename
     */
    basename: string;
    /**
     * Upload filename
     */
    filename: string;
    /**
     * Upload URL
     */
    url: string;
    /**
     * Format
     */
    format: string | null;
    /**
     * Author
     */
    author: string | null;
    /**
     * Copyright
     */
    copyright: string | null;
    /**
     * Notes
     */
    notes: string | null;
    /**
     * The MD5 hash of the asset
     */
    md5: string;
    /**
     * Seconds of duration for the video
     */
    duration: number | null;
    /**
     * Frame rate (FPS) for the video
     */
    frame_rate: number | null;
    /**
     * Blurhash for the asset
     */
    blurhash: string | null;
    /**
     * Public Mux playback ID. Used with stream.mux.com to create the source URL for a video player.
     */
    mux_playback_id: string | null;
    /**
     * Maximum quality of MP4 rendition available
     */
    mux_mp4_highest_res: null | 'high' | 'medium' | 'low';
    /**
     * For each of the project's locales, the default metadata to apply if nothing is specified at record's level.
     */
    default_field_metadata: {
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^(?<languagecode>[a-z]{0,3}(-[A-Za-z]+)?(-[A-Z]{0,3})?)$".
         */
        [k: string]: {
            /**
             * Alternate text for the asset
             */
            alt: string | null;
            /**
             * Title for the asset
             */
            title: string | null;
            /**
             * Object with arbitrary metadata
             */
            custom_data: {
                [k: string]: unknown;
            };
            /**
             * Focal point (only for image assets)
             */
            focal_point: {
                /**
                 * Horizontal position expressed as float between 0 and 1
                 */
                x: number;
                /**
                 * Vertical position expressed as float between 0 and 1
                 */
                y: number;
            } | null;
        };
    };
    /**
     * Is this upload an image?
     */
    is_image: boolean;
    /**
     * Date of upload
     */
    created_at: null | string;
    /**
     * Date of last update
     */
    updated_at: null | string;
    /**
     * Mime type of upload
     */
    mime_type: null | string;
    /**
     * Tags
     */
    tags: string[];
    /**
     * Smart tags
     */
    smart_tags: string[];
    /**
     * Exif information
     */
    exif_info: {
        [k: string]: unknown;
    };
    /**
     * Dominant colors of the image
     */
    colors: {
        /**
         * Red value (from 0 to 255)
         */
        red: number;
        /**
         * Green value (from 0 to 255)
         */
        green: number;
        /**
         * Blue value (from 0 to 255)
         */
        blue: number;
        /**
         * Alpha value (from 0 to 255)
         */
        alpha: number;
    }[];
};
/**
 * JSON API links
 *
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type UploadRelationships = {
    creator: AccountData | AccessTokenData | UserData | SsoUserData;
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type UploadCreateSchema = {
    type?: UploadType;
    /**
     * Upload path
     */
    path: string;
    /**
     * Copyright
     */
    copyright?: string | null;
    /**
     * Author
     */
    author?: string | null;
    /**
     * Notes
     */
    notes?: string | null;
    /**
     * For each of the project's locales, the default metadata to apply if nothing is specified at record's level.
     */
    default_field_metadata?: {
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^(?<languagecode>[a-z]{0,3}(-[A-Za-z]+)?(-[A-Z]{0,3})?)$".
         */
        [k: string]: {
            /**
             * Alternate text for the asset
             */
            alt?: string | null;
            /**
             * Title for the asset
             */
            title?: string | null;
            /**
             * Object with arbitrary metadata
             */
            custom_data?: {
                [k: string]: unknown;
            };
            /**
             * Focal point (only for image assets)
             */
            focal_point?: {
                /**
                 * Horizontal position expressed as float between 0 and 1
                 */
                x: number;
                /**
                 * Vertical position expressed as float between 0 and 1
                 */
                y: number;
            } | null;
        };
    };
    /**
     * Tags
     */
    tags?: string[];
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type UploadUpdateSchema = {
    id?: UploadIdentity;
    type?: UploadType;
    /**
     * Upload path
     */
    path?: string;
    /**
     * Upload basename
     */
    basename?: string;
    /**
     * Copyright
     */
    copyright?: string | null;
    /**
     * Author
     */
    author?: string | null;
    /**
     * Notes
     */
    notes?: string | null;
    /**
     * Tags
     */
    tags?: string[];
    /**
     * For each of the project's locales, the default metadata to apply if nothing is specified at record's level.
     */
    default_field_metadata?: {
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^(?<languagecode>[a-z]{0,3}(-[A-Za-z]+)?(-[A-Z]{0,3})?)$".
         */
        [k: string]: {
            /**
             * Alternate text for the asset
             */
            alt?: string | null;
            /**
             * Title for the asset
             */
            title?: string | null;
            /**
             * Object with arbitrary metadata
             */
            custom_data?: {
                [k: string]: unknown;
            };
            /**
             * Focal point (only for image assets)
             */
            focal_point?: {
                /**
                 * Horizontal position expressed as float between 0 and 1
                 */
                x: number;
                /**
                 * Vertical position expressed as float between 0 and 1
                 */
                y: number;
            } | null;
        };
    };
    creator?: AccountData | AccessTokenData | UserData | SsoUserData;
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `batch_add_tags.schema` link.
 */
export declare type UploadBatchAddTagsSchema = {
    type?: UploadType;
    /**
     * Tags
     */
    tags?: string[];
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `bulk_tag.schema` link.
 */
export declare type UploadBulkTagSchema = {
    /**
     * JSON API type field
     */
    type?: 'upload_bulk_tag_operation';
    /**
     * The tags to add to the assets
     */
    tags: string[];
    uploads: UploadData[];
};
/**
 * This interface was referenced by `Upload`'s JSON-Schema
 * via the `bulk_destroy.schema` link.
 */
export declare type UploadBulkDestroySchema = {
    /**
     * JSON API type field
     */
    type?: 'upload_bulk_destroy_operation';
    uploads: UploadData[];
    [k: string]: unknown;
};
/**
 * To upload a file in DatoCMS, first you need to obtain an upload permission through this API endpoint. The response will contain the S3 URL where you will be able to upload the file with a direct PUT request.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "upload_request".
 */
export declare type UploadRequest = {
    id: UploadRequestIdentity;
    type: UploadRequestType;
    /**
     * The URL to use to upload the file with a direct PUT request
     */
    url: string;
};
export declare type UploadRequestCreateTargetSchema = UploadRequest;
/**
 * JSON API attributes
 *
 * This interface was referenced by `UploadRequest`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type UploadRequestAttributes = {
    /**
     * The URL to use to upload the file with a direct PUT request
     */
    url: string;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `UploadRequest`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type UploadRequestCreateSchema = {
    type?: UploadRequestType;
    /**
     * The original file name
     */
    filename?: string;
};
/**
 * You can create scheduled publication to publish records in the future
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "scheduled_publication".
 */
export declare type ScheduledPublication = {
    id: ScheduledPublicationIdentity;
    type: ScheduledPublicationType;
    /**
     * The future date for the publication
     */
    publication_scheduled_at: string;
    item: ItemData;
};
export declare type ScheduledPublicationCreateTargetSchema = ScheduledPublication;
/**
 * JSON API data
 *
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type ScheduledPublicationData = {
    type: ScheduledPublicationType;
    id: ScheduledPublicationIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type ScheduledPublicationAttributes = {
    /**
     * The future date for the publication
     */
    publication_scheduled_at: string;
};
/**
 * JSON API links
 *
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type ScheduledPublicationRelationships = {
    item: ItemData;
};
/**
 * This interface was referenced by `ScheduledPublication`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type ScheduledPublicationCreateSchema = {
    type?: ScheduledPublicationType;
    [k: string]: unknown;
};
/**
 * You can create a scheduled unpublishing to unpublish records in the future
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "scheduled_unpublishing".
 */
export declare type ScheduledUnpublishing = {
    id: ScheduledUnpublishingIdentity;
    type: ScheduledUnpublishingType;
    /**
     * The future date for the unpublishing
     */
    unpublishing_scheduled_at: string;
    item: ItemData;
};
export declare type ScheduledUnpublishingCreateTargetSchema = ScheduledUnpublishing;
/**
 * JSON API data
 *
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type ScheduledUnpublishingData = {
    type: ScheduledUnpublishingType;
    id: ScheduledUnpublishingIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type ScheduledUnpublishingAttributes = {
    /**
     * The future date for the unpublishing
     */
    unpublishing_scheduled_at: string;
};
/**
 * JSON API links
 *
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type ScheduledUnpublishingRelationships = {
    item: ItemData;
};
/**
 * This interface was referenced by `ScheduledUnpublishing`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type ScheduledUnpublishingCreateSchema = {
    type?: ScheduledUnpublishingType;
    [k: string]: unknown;
};
/**
 * DatoCMS Site Search is a way to deliver tailored search results to your site visitors. This is the endpoint you can use to query for results.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "search_result".
 */
export declare type SearchResult = {
    id: SearchResultIdentity;
    type: SearchResultType;
    /**
     * Title of the page
     */
    title: string;
    /**
     * First 200 characters of page body, unformatted
     */
    body_excerpt: string;
    /**
     * URL
     */
    url: string;
    /**
     * Search score
     */
    score: number;
    highlight: {
        title?: string[] | null;
        body?: string[] | null;
    };
};
/**
 * JSON API data
 *
 * This interface was referenced by `SearchResult`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SearchResultData = {
    type: SearchResultType;
    id: SearchResultIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `SearchResult`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SearchResultAttributes = {
    /**
     * Title of the page
     */
    title: string;
    /**
     * First 200 characters of page body, unformatted
     */
    body_excerpt: string;
    /**
     * URL
     */
    url: string;
    /**
     * Search score
     */
    score: number;
    highlight: {
        title?: string[] | null;
        body?: string[] | null;
    };
};
/**
 * [Environments](https://www.datocms.com/docs/general-concepts/primary-and-sandbox-environments) make it easier for your development team to **manage and maintain content structure once your content has been published**. You can think of environments like code branches: great for testing, development and pre-production environments.
 *
 * By default, every project has one environment, called **primary environment**, which is meant to be used for the regular editorial workflow. Additionally, multiple **sandbox environments** can be created by developers to safely test/experiment new changes in the content.
 *
 * Sandbox environments start out as **exact copies of one of the existing environments** (ie. the primary one). The process of creating a new sandbox starting off from an existing environment is called fork.
 *
 * Each environment is identified by a name (ie. `master`) and stores the following information:
 *
 * - Models
 * - Records
 * - Uploads
 * - Plugins
 * - Locales and timezone settings
 * - UI Theme (colors and logo)
 * - Global SEO settings
 * - The content navigation bar
 *
 * When making changes to any of the aforementioned entities in any environment, including the primary environment, **the data in all other environments isn’t affected** and stays the same.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "environment".
 */
export declare type Environment = {
    id: EnvironmentIdentity;
    type: EnvironmentType;
    meta: EnvironmentMeta;
};
export declare type EnvironmentForkJobSchema = Environment;
export declare type EnvironmentPromoteTargetSchema = Environment;
export declare type EnvironmentSelfTargetSchema = Environment;
export declare type EnvironmentDestroyJobSchema = Environment;
/**
 * Meta attributes
 *
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type EnvironmentMeta = {
    /**
     * Status of the environment
     */
    status: 'creating' | 'ready' | 'destroying';
    /**
     * Date of creation
     */
    created_at: string;
    /**
     * Last data change
     */
    last_data_change_at: string;
    /**
     * Is this environment the primary for the project?
     */
    primary: boolean;
    /**
     * ID of the environment that's been forked to generate this one
     */
    forked_from?: string | null;
};
/**
 * JSON API data
 *
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type EnvironmentData = {
    type: EnvironmentType;
    id: EnvironmentIdentity;
};
/**
 * This interface was referenced by `Environment`'s JSON-Schema
 * via the `fork.schema` link.
 */
export declare type EnvironmentForkSchema = {
    /**
     * The ID of the forked environment
     */
    id?: string;
    type?: EnvironmentType;
    [k: string]: unknown;
};
/**
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "maintenance_mode".
 */
export declare type MaintenanceMode = {
    id: MaintenanceModeIdentity;
    type: MaintenanceModeType;
    /**
     * Whether maintenance mode is currently active or not
     */
    active: boolean;
};
export declare type MaintenanceModeSelfTargetSchema = MaintenanceMode;
export declare type MaintenanceModeActivateTargetSchema = MaintenanceMode;
export declare type MaintenanceModeDeactivateTargetSchema = MaintenanceMode;
/**
 * JSON API data
 *
 * This interface was referenced by `MaintenanceMode`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type MaintenanceModeData = {
    type: MaintenanceModeType;
    id: MaintenanceModeIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `MaintenanceMode`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type MaintenanceModeAttributes = {
    /**
     * Whether maintenance mode is currently active or not
     */
    active: boolean;
};
/**
 * A webhook allows to make requests following certain Dato events. It is linked to a Role, which describes what actions can be performed.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "webhook".
 */
export declare type Webhook = {
    id: WebhookIdentity;
    type: WebhookType;
    /**
     * Unique name for the webhook
     */
    name: string;
    /**
     * Whether the webhook is enabled and sending events or not
     */
    enabled: boolean;
    /**
     * The URL to be called
     */
    url: string;
    /**
     * A custom payload
     */
    custom_payload: string | null;
    /**
     * HTTP Basic Authorization username
     */
    http_basic_user: string | null;
    /**
     * HTTP Basic Authorization password
     */
    http_basic_password: string | null;
    /**
     * Additional headers that will be sent
     */
    headers: {
        [k: string]: unknown;
    };
    /**
     * All the events you will be notified for
     */
    events: unknown[];
    /**
     * Specifies which API version to use when serializing entities in the webhook payload
     */
    payload_api_version: string;
    /**
     * Whether the you want records present in the payload to show blocks expanded or not
     */
    nested_items_in_payload: boolean;
};
export declare type WebhookCreateTargetSchema = Webhook;
export declare type WebhookUpdateTargetSchema = Webhook;
export declare type WebhookSelfTargetSchema = Webhook;
export declare type WebhookDestroyTargetSchema = Webhook;
/**
 * JSON API data
 *
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type WebhookData = {
    type: WebhookType;
    id: WebhookIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type WebhookAttributes = {
    /**
     * Unique name for the webhook
     */
    name: string;
    /**
     * Whether the webhook is enabled and sending events or not
     */
    enabled: boolean;
    /**
     * The URL to be called
     */
    url: string;
    /**
     * A custom payload
     */
    custom_payload: string | null;
    /**
     * HTTP Basic Authorization username
     */
    http_basic_user: string | null;
    /**
     * HTTP Basic Authorization password
     */
    http_basic_password: string | null;
    /**
     * Additional headers that will be sent
     */
    headers: {
        [k: string]: unknown;
    };
    /**
     * All the events you will be notified for
     */
    events: unknown[];
    /**
     * Specifies which API version to use when serializing entities in the webhook payload
     */
    payload_api_version: string;
    /**
     * Whether the you want records present in the payload to show blocks expanded or not
     */
    nested_items_in_payload: boolean;
};
/**
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type WebhookCreateSchema = {
    type?: WebhookType;
    /**
     * Unique name for the webhook
     */
    name: string;
    /**
     * The URL to be called
     */
    url: string;
    /**
     * A custom payload
     */
    custom_payload: string | null;
    /**
     * Additional headers that will be sent
     */
    headers: {
        [k: string]: unknown;
    };
    /**
     * All the events you will be notified for
     */
    events: unknown[];
    /**
     * HTTP Basic Authorization username
     */
    http_basic_user: string | null;
    /**
     * HTTP Basic Authorization password
     */
    http_basic_password: string | null;
    /**
     * Whether the webhook is enabled and sending events or not
     */
    enabled?: boolean;
    /**
     * Specifies which API version to use when serializing entities in the webhook payload
     */
    payload_api_version?: string;
    /**
     * Whether the you want records present in the payload to show blocks expanded or not
     */
    nested_items_in_payload?: boolean;
};
/**
 * This interface was referenced by `Webhook`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type WebhookUpdateSchema = {
    id?: WebhookIdentity;
    type?: WebhookType;
    /**
     * Unique name for the webhook
     */
    name?: string;
    /**
     * The URL to be called
     */
    url?: string;
    /**
     * A custom payload
     */
    custom_payload?: string | null;
    /**
     * Additional headers that will be sent
     */
    headers?: {
        [k: string]: unknown;
    };
    /**
     * All the events you will be notified for
     */
    events?: unknown[];
    /**
     * HTTP Basic Authorization username
     */
    http_basic_user?: string | null;
    /**
     * HTTP Basic Authorization password
     */
    http_basic_password?: string | null;
    /**
     * Whether the webhook is enabled and sending events or not
     */
    enabled?: boolean;
    /**
     * Specifies which API version to use when serializing entities in the webhook payload
     */
    payload_api_version?: string;
    /**
     * Whether the you want records present in the payload to show blocks expanded or not
     */
    nested_items_in_payload?: boolean;
};
/**
 * Represents a log entry in the webhooks activity list.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "webhook_call".
 */
export declare type WebhookCall = {
    id: WebhookCallIdentity;
    type: WebhookCallType;
    /**
     * The subject of webhook triggering
     */
    entity_type: 'item' | 'item_type' | 'upload';
    /**
     * The event that triggers the webhook call
     */
    event_type: 'create' | 'update' | 'delete' | 'publish' | 'unpublish';
    /**
     * The moment the call occurred
     */
    created_at: string;
    /**
     * The url that the webhook called
     */
    request_url: string;
    /**
     * The request's headers
     */
    request_headers: {
        [k: string]: unknown;
    };
    /**
     * The body of the request
     */
    request_payload: string;
    /**
     * The status of the response
     */
    response_status: number | null;
    /**
     * The response's headers
     */
    response_headers: {
        [k: string]: unknown;
    };
    /**
     * The body of the response
     */
    response_payload: string | null;
    webhook: WebhookData;
};
/**
 * JSON API data
 *
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type WebhookCallData = {
    type: WebhookCallType;
    id: WebhookCallIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type WebhookCallAttributes = {
    /**
     * The subject of webhook triggering
     */
    entity_type: 'item' | 'item_type' | 'upload';
    /**
     * The event that triggers the webhook call
     */
    event_type: 'create' | 'update' | 'delete' | 'publish' | 'unpublish';
    /**
     * The moment the call occurred
     */
    created_at: string;
    /**
     * The url that the webhook called
     */
    request_url: string;
    /**
     * The request's headers
     */
    request_headers: {
        [k: string]: unknown;
    };
    /**
     * The body of the request
     */
    request_payload: string;
    /**
     * The status of the response
     */
    response_status: number | null;
    /**
     * The response's headers
     */
    response_headers: {
        [k: string]: unknown;
    };
    /**
     * The body of the response
     */
    response_payload: string | null;
};
/**
 * JSON API links
 *
 * This interface was referenced by `WebhookCall`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type WebhookCallRelationships = {
    webhook: WebhookData;
};
/**
 * Configuration for different build triggers. You can have different staging and production environments in order to test your site before final deploy
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "build_trigger".
 */
export declare type BuildTrigger = {
    id: BuildTriggerIdentity;
    type: BuildTriggerType;
    /**
     * Name of the environment
     */
    name: string;
    /**
     * The deploy adapter
     */
    adapter: string;
    /**
     * Additional configuration for deploy
     */
    adapter_settings: {
        [k: string]: unknown;
    };
    /**
     * Timestamp of the last deploy
     */
    last_build_completed_at: string | null;
    /**
     * Status of last deploy
     */
    build_status: string;
    /**
     * Unique token of the webhook
     */
    webhook_token?: string;
    /**
     * Notification webhook URL
     */
    webhook_url: string;
    /**
     * Status of site scraper
     */
    indexing_status: string;
    /**
     * Public url of the site
     */
    frontend_url: string | null;
    /**
     * Deploy on scheduled publication
     */
    autotrigger_on_scheduled_publications: boolean;
    /**
     * Enable scraper on the site
     */
    indexing_enabled: boolean;
};
export declare type BuildTriggerSelfTargetSchema = BuildTrigger;
export declare type BuildTriggerCreateTargetSchema = BuildTrigger;
export declare type BuildTriggerUpdateTargetSchema = BuildTrigger;
export declare type BuildTriggerDestroyTargetSchema = BuildTrigger;
/**
 * JSON API attributes
 *
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type BuildTriggerAttributes = {
    /**
     * Name of the environment
     */
    name: string;
    /**
     * The deploy adapter
     */
    adapter: string;
    /**
     * Additional configuration for deploy
     */
    adapter_settings: {
        [k: string]: unknown;
    };
    /**
     * Timestamp of the last deploy
     */
    last_build_completed_at: string | null;
    /**
     * Status of last deploy
     */
    build_status: string;
    /**
     * Unique token of the webhook
     */
    webhook_token?: string;
    /**
     * Notification webhook URL
     */
    webhook_url: string;
    /**
     * Status of site scraper
     */
    indexing_status: string;
    /**
     * Public url of the site
     */
    frontend_url: string | null;
    /**
     * Deploy on scheduled publication
     */
    autotrigger_on_scheduled_publications: boolean;
    /**
     * Enable scraper on the site
     */
    indexing_enabled: boolean;
};
/**
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type BuildTriggerCreateSchema = {
    type?: BuildTriggerType;
    /**
     * Name of the environment
     */
    name: string;
    /**
     * Unique token of the webhook
     */
    webhook_token?: string;
    /**
     * The deploy adapter
     */
    adapter: string;
    /**
     * Enable scraper on the site
     */
    indexing_enabled: boolean;
    /**
     * Public url of the site
     */
    frontend_url: string | null;
    /**
     * Deploy on scheduled publication
     */
    autotrigger_on_scheduled_publications: boolean;
    /**
     * Additional configuration for deploy
     */
    adapter_settings: {
        [k: string]: unknown;
    };
};
/**
 * This interface was referenced by `BuildTrigger`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type BuildTriggerUpdateSchema = {
    id?: BuildTriggerIdentity;
    type?: BuildTriggerType;
    /**
     * Name of the environment
     */
    name?: string;
    /**
     * The deploy adapter
     */
    adapter?: string;
    /**
     * Enable scraper on the site
     */
    indexing_enabled?: boolean;
    /**
     * Public url of the site
     */
    frontend_url?: string | null;
    /**
     * Deploy on scheduled publication
     */
    autotrigger_on_scheduled_publications?: boolean;
    /**
     * Additional configuration for deploy
     */
    adapter_settings?: {
        [k: string]: unknown;
    };
};
/**
 * In DatoCMS you can create filters to help you (and other editors) quickly search for records
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "item_type_filter".
 */
export declare type ItemTypeFilter = {
    id: ItemTypeFilterIdentity;
    type: ItemTypeFilterType;
    /**
     * The name of the filter
     */
    name: string;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
    /**
     * Whether it's a shared filter or not
     */
    shared: boolean;
    item_type: ItemTypeData;
};
export declare type ItemTypeFilterCreateTargetSchema = ItemTypeFilter;
export declare type ItemTypeFilterUpdateTargetSchema = ItemTypeFilter;
export declare type ItemTypeFilterSelfTargetSchema = ItemTypeFilter;
export declare type ItemTypeFilterDestroyTargetSchema = ItemTypeFilter;
/**
 * JSON API data
 *
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type ItemTypeFilterData = {
    type: ItemTypeFilterType;
    id: ItemTypeFilterIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type ItemTypeFilterAttributes = {
    /**
     * The name of the filter
     */
    name: string;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
    /**
     * Whether it's a shared filter or not
     */
    shared: boolean;
};
/**
 * JSON API links
 *
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type ItemTypeFilterRelationships = {
    item_type: ItemTypeData;
};
/**
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type ItemTypeFilterCreateSchema = {
    type?: ItemTypeFilterType;
    /**
     * The name of the filter
     */
    name: string;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
    /**
     * Whether it's a shared filter or not
     */
    shared: boolean;
    item_type: ItemTypeData;
};
/**
 * This interface was referenced by `ItemTypeFilter`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type ItemTypeFilterUpdateSchema = {
    id?: ItemTypeFilterIdentity;
    type?: ItemTypeFilterType;
    /**
     * The name of the filter
     */
    name: string;
    /**
     * Whether it's a shared filter or not
     */
    shared?: boolean;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
};
/**
 * In DatoCMS you can create filters to help you (and other editors) quickly search for uploads
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "upload_filter".
 */
export declare type UploadFilter = {
    id: UploadFilterIdentity;
    type: UploadFilterType;
    /**
     * The name of the filter
     */
    name: string;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
    /**
     * Whether it's a shared filter or not
     */
    shared: boolean;
};
export declare type UploadFilterCreateTargetSchema = UploadFilter;
export declare type UploadFilterUpdateTargetSchema = UploadFilter;
export declare type UploadFilterSelfTargetSchema = UploadFilter;
export declare type UploadFilterDestroyTargetSchema = UploadFilter;
/**
 * JSON API data
 *
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type UploadFilterData = {
    type: UploadFilterType;
    id: UploadFilterIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type UploadFilterAttributes = {
    /**
     * The name of the filter
     */
    name: string;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
    /**
     * Whether it's a shared filter or not
     */
    shared: boolean;
};
/**
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type UploadFilterCreateSchema = {
    type?: UploadFilterType;
    /**
     * The name of the filter
     */
    name: string;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
    /**
     * Whether it's a shared filter or not
     */
    shared: boolean;
};
/**
 * This interface was referenced by `UploadFilter`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type UploadFilterUpdateSchema = {
    id?: UploadFilterIdentity;
    type?: UploadFilterType;
    /**
     * The name of the filter
     */
    name: string;
    /**
     * Whether it's a shared filter or not
     */
    shared?: boolean;
    /**
     * The actual filter
     */
    filter: {
        [k: string]: unknown;
    };
};
/**
 * A DatoCMS administrative area can be accessed by multiple people. Every invitation is linked to a specific Role, which describes what actions it will be able to perform once the user will register.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "site_invitation".
 */
export declare type SiteInvitation = {
    id: SiteInvitationIdentity;
    type: SiteInvitationType;
    /**
     * Email
     */
    email: string;
    role: RoleData;
};
export declare type SiteInvitationCreateTargetSchema = SiteInvitation;
export declare type SiteInvitationUpdateTargetSchema = SiteInvitation;
export declare type SiteInvitationSelfTargetSchema = SiteInvitation;
export declare type SiteInvitationDestroyTargetSchema = SiteInvitation;
/**
 * JSON API data
 *
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SiteInvitationData = {
    type: SiteInvitationType;
    id: SiteInvitationIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SiteInvitationAttributes = {
    /**
     * Email
     */
    email: string;
};
/**
 * JSON API links
 *
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type SiteInvitationRelationships = {
    role: RoleData;
};
/**
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type SiteInvitationCreateSchema = {
    type?: SiteInvitationType;
    /**
     * Email
     */
    email: string;
    role: RoleData;
};
/**
 * This interface was referenced by `SiteInvitation`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type SiteInvitationUpdateSchema = {
    id?: SiteInvitationIdentity;
    type?: SiteInvitationType;
    role?: RoleData;
    [k: string]: unknown;
};
/**
 * Session track users movements in the administrative area, and allows locking a record when editing it.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "editing_session".
 */
export declare type EditingSession = {
    id: EditingSessionIdentity;
    type: EditingSessionType;
    /**
     * User entered at
     */
    last_activity_at: string | null;
    /**
     * User locked record at
     */
    locked_at: string | null;
    active_item: ItemData;
    active_item_type: ItemTypeData;
    editor: AccountData | AccessTokenData | UserData;
};
export declare type EditingSessionUpdateTargetSchema = EditingSession;
export declare type EditingSessionDestroyTargetSchema = EditingSession;
/**
 * JSON API data
 *
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type EditingSessionData = {
    type: EditingSessionType;
    id: EditingSessionIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type EditingSessionAttributes = {
    /**
     * User entered at
     */
    last_activity_at: string | null;
    /**
     * User locked record at
     */
    locked_at: string | null;
};
/**
 * JSON API links
 *
 * This interface was referenced by `EditingSession`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type EditingSessionRelationships = {
    active_item: ItemData;
    active_item_type: ItemTypeData;
    editor: AccountData | AccessTokenData | UserData;
};
/**
 * A Single Sign-On group exists when a DatoCMS project is connected to an Identity Provider. These groups can be used to link DatoCMS roles to the Identity Provider's groups.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "sso_group".
 */
export declare type SsoGroup = {
    id: SsoGroupIdentity;
    type: SsoGroupType;
    /**
     * Name of the group
     */
    name: string;
    /**
     * When an user belongs to multiple groups, the role associated to the group with the highest priority will be used
     */
    priority: number;
    role: RoleData;
    users: SsoUserData[];
};
export declare type SsoGroupCopyRolesTargetSchema = SsoGroup;
export declare type SsoGroupUpdateTargetSchema = SsoGroup;
export declare type SsoGroupDestroyTargetSchema = SsoGroup;
/**
 * JSON API attributes
 *
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SsoGroupAttributes = {
    /**
     * Name of the group
     */
    name: string;
    /**
     * When an user belongs to multiple groups, the role associated to the group with the highest priority will be used
     */
    priority: number;
};
/**
 * JSON API links
 *
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type SsoGroupRelationships = {
    role: RoleData;
    users: SsoUserData[];
};
/**
 * This interface was referenced by `SsoGroup`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type SsoGroupUpdateSchema = {
    id?: SsoGroupIdentity;
    type?: SsoGroupType;
    /**
     * When an user belongs to multiple groups, the role associated to the group with the highest priority will be used
     */
    priority: number;
    role: RoleData;
};
/**
 * Represents the Single Sign-on settings of the current DatoCMS project
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "sso_settings".
 */
export declare type SsoSettings = {
    id: SsoSettingsIdentity;
    type: SsoSettingsType;
    /**
     * URL of Identity Provider SAML Metadata endpoint
     */
    idp_saml_metadata_url: null | string;
    /**
     * DatoCMS SCIM base URL
     */
    scim_base_url: string;
    /**
     * DatoCMS SAML ACS URL
     */
    saml_acs_url: string;
    /**
     * DatoCMS SAML Metadata URL
     */
    sp_saml_metadata_url: string;
    /**
     * DatoCMS SAML Base URL
     */
    sp_saml_base_url: string;
    /**
     * DatoCMS SAML Token
     */
    saml_token: string;
    /**
     * DatoCMS SCIM API Token
     */
    scim_api_token?: string;
    default_role: null | RoleData;
};
export declare type SsoSettingsSelfTargetSchema = SsoSettings;
export declare type SsoSettingsUpdateTargetSchema = SsoSettings;
/**
 * JSON API data
 *
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SsoSettingsData = {
    type: SsoSettingsType;
    id: SsoSettingsIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SsoSettingsAttributes = {
    /**
     * URL of Identity Provider SAML Metadata endpoint
     */
    idp_saml_metadata_url: null | string;
    /**
     * DatoCMS SCIM base URL
     */
    scim_base_url: string;
    /**
     * DatoCMS SAML ACS URL
     */
    saml_acs_url: string;
    /**
     * DatoCMS SAML Metadata URL
     */
    sp_saml_metadata_url: string;
    /**
     * DatoCMS SAML Base URL
     */
    sp_saml_base_url: string;
    /**
     * DatoCMS SAML Token
     */
    saml_token: string;
    /**
     * DatoCMS SCIM API Token
     */
    scim_api_token?: string;
};
/**
 * JSON API links
 *
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type SsoSettingsRelationships = {
    default_role: null | RoleData;
};
/**
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `generate_token.targetSchema` link.
 */
export declare type SsoSettingsGenerateTokenTargetSchema = {
    id: SsoSettingsIdentity;
    /**
     * JSON API type field
     */
    type: 'sso_token';
    attributes: {
        /**
         * DatoCMS SCIM API Token
         */
        scim_api_token: string;
    };
    [k: string]: unknown;
};
/**
 * This interface was referenced by `SsoSettings`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type SsoSettingsUpdateSchema = {
    id?: SsoSettingsIdentity;
    type?: SsoSettingsType;
    /**
     * URL of Identity Provider SAML Metadata endpoint
     */
    idp_saml_metadata_url?: null | string;
    default_role: RoleData;
};
/**
 * Represents the white-label settings of the current DatoCMS project
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "white_label_settings".
 */
export declare type WhiteLabelSettings = {
    id: WhiteLabelSettingsIdentity;
    type: WhiteLabelSettingsType;
    /**
     * URL of custom I18n messages. The :locale placeholder represents the current DatoCMS UI locale.
     */
    custom_i18n_messages_template_url: null | string;
};
export declare type WhiteLabelSettingsSelfTargetSchema = WhiteLabelSettings;
export declare type WhiteLabelSettingsUpdateTargetSchema = WhiteLabelSettings;
/**
 * JSON API data
 *
 * This interface was referenced by `WhiteLabelSettings`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type WhiteLabelSettingsData = {
    type: WhiteLabelSettingsType;
    id: WhiteLabelSettingsIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `WhiteLabelSettings`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type WhiteLabelSettingsAttributes = {
    /**
     * URL of custom I18n messages. The :locale placeholder represents the current DatoCMS UI locale.
     */
    custom_i18n_messages_template_url: null | string;
};
/**
 * This interface was referenced by `WhiteLabelSettings`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type WhiteLabelSettingsUpdateSchema = {
    id?: WhiteLabelSettingsIdentity;
    type?: WhiteLabelSettingsType;
    /**
     * URL of custom I18n messages. The :locale placeholder represents the current DatoCMS UI locale.
     */
    custom_i18n_messages_template_url?: null | string;
};
/**
 * Info that can be accessed by unauthorized users
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "public_info".
 */
export declare type PublicInfo = {
    id: PublicInfoIdentity;
    type: PublicInfoType;
    /**
     * Site name
     */
    name: string;
    /**
     * Specifies the Single Sign-on URL to reach
     */
    sso_saml_init_url: null | string;
    /**
     * Specifies the logo url if present
     */
    logo_url: null | string;
    /**
     * Specifies whether the project is in white-label mode
     */
    white_label: boolean;
    /**
     * Template URL to download specific I18n messages (for white-label projects only)
     */
    custom_i18n_messages_template_url: null | string;
    /**
     * Specifies the color-scheme for the project
     */
    theme: {
        primary_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        light_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        accent_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        dark_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * Additional information (only returned on authenticated requests)
     */
    extras: null | {
        blocks_depth: number;
        blocks_per_item: number;
        maximum_single_upload_bytes: number;
        [k: string]: unknown;
    };
};
export declare type PublicInfoSelfTargetSchema = PublicInfo;
/**
 * JSON API data
 *
 * This interface was referenced by `PublicInfo`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type PublicInfoData = {
    type: PublicInfoType;
    id: PublicInfoIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `PublicInfo`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type PublicInfoAttributes = {
    /**
     * Site name
     */
    name: string;
    /**
     * Specifies the Single Sign-on URL to reach
     */
    sso_saml_init_url: null | string;
    /**
     * Specifies the logo url if present
     */
    logo_url: null | string;
    /**
     * Specifies whether the project is in white-label mode
     */
    white_label: boolean;
    /**
     * Template URL to download specific I18n messages (for white-label projects only)
     */
    custom_i18n_messages_template_url: null | string;
    /**
     * Specifies the color-scheme for the project
     */
    theme: {
        primary_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        light_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        accent_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        dark_color?: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        [k: string]: unknown;
    };
    /**
     * Additional information (only returned on authenticated requests)
     */
    extras: null | {
        blocks_depth: number;
        blocks_per_item: number;
        maximum_single_upload_bytes: number;
        [k: string]: unknown;
    };
};
/**
 * DatoCMS resources usage organized by day
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "daily_usage".
 */
export declare type DailyUsage = {
    id: DailyUsageIdentity;
    type: DailyUsageType;
    /**
     * The date the data are referring to
     */
    date: string;
    /**
     * Number of API calls to content delivery API
     */
    cda_api_calls: number;
    /**
     * Number of API calls to content management API
     */
    cma_api_calls: number;
    /**
     * Content delivery API traffic
     */
    cda_traffic_bytes: number;
    /**
     * Uploads requests traffic
     */
    assets_traffic_bytes: number;
    /**
     * Video streaming seconds
     */
    mux_delivered_seconds: number;
};
/**
 * JSON API data
 *
 * This interface was referenced by `DailyUsage`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type DailyUsageData = {
    type: DailyUsageType;
    id: DailyUsageIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `DailyUsage`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type DailyUsageAttributes = {
    /**
     * The date the data are referring to
     */
    date: string;
    /**
     * Number of API calls to content delivery API
     */
    cda_api_calls: number;
    /**
     * Number of API calls to content management API
     */
    cma_api_calls: number;
    /**
     * Content delivery API traffic
     */
    cda_traffic_bytes: number;
    /**
     * Uploads requests traffic
     */
    assets_traffic_bytes: number;
    /**
     * Video streaming seconds
     */
    mux_delivered_seconds: number;
};
/**
 * You can use counters to analyze your project's data consumption over a period of time. Counters are especially useful if your project is exceeding its API calls/traffic quota limits, to better understand where and how requests are originating. Counters are updated every minute, so you can debug in real-time the results of your changes.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "usage_counter".
 */
export declare type UsageCounter = {
    id: UsageCounterIdentity;
    type: UsageCounterType;
    result: {
        /**
         * Occurrence
         */
        value: string;
        /**
         * Counter for the specified occurrence
         */
        counter: number;
    }[];
};
export declare type UsageCounterSelfTargetSchema = UsageCounter;
/**
 * JSON API data
 *
 * This interface was referenced by `UsageCounter`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type UsageCounterData = {
    type: UsageCounterType;
    id: UsageCounterIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `UsageCounter`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type UsageCounterAttributes = {
    result: {
        /**
         * Occurrence
         */
        value: string;
        /**
         * Counter for the specified occurrence
         */
        counter: number;
    }[];
};
/**
 * All the project's upload tags
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "upload_tag".
 */
export declare type UploadTag = {
    id: UploadTagIdentity;
    type: UploadTagType;
    /**
     * The tag name
     */
    name: string;
};
export declare type UploadTagCreateTargetSchema = UploadTag;
/**
 * JSON API data
 *
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type UploadTagData = {
    type: UploadTagType;
    id: UploadTagIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type UploadTagAttributes = {
    /**
     * The tag name
     */
    name: string;
};
/**
 * This interface was referenced by `UploadTag`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type UploadTagCreateSchema = {
    type?: UploadTagType;
    /**
     * The tag name
     */
    name: string;
};
/**
 * All the site's upload automatically generated tags
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "upload_smart_tag".
 */
export declare type UploadSmartTag = {
    id: UploadSmartTagIdentity;
    type: UploadSmartTagType;
    /**
     * The tag name
     */
    name: string;
};
/**
 * JSON API data
 *
 * This interface was referenced by `UploadSmartTag`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type UploadSmartTagData = {
    type: UploadSmartTagType;
    id: UploadSmartTagIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `UploadSmartTag`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type UploadSmartTagAttributes = {
    /**
     * The tag name
     */
    name: string;
};
/**
 * A site represents a specific DatoCMS administrative area
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "site".
 */
export declare type Site = {
    id: SiteIdentity;
    type: SiteType;
    /**
     * Site name
     */
    name: string;
    /**
     * Administrative area custom domain
     */
    domain: string | null;
    /**
     * Google API Key to be used by the LatLon widget
     */
    google_maps_api_token: string | null;
    /**
     * Imgix host
     */
    imgix_host: string | null;
    /**
     * DatoCMS internal domain for the administrative area
     */
    internal_domain: string | null;
    /**
     * Available locales
     */
    locales: [string, ...string[]];
    /**
     * Site default timezone
     */
    timezone: string;
    /**
     * Whether the website needs to be indexed by search engines or not
     */
    no_index: boolean;
    /**
     * The upload id for the favicon
     */
    favicon: string | null;
    /**
     * Specifies the last time when a change of data occurred
     */
    last_data_change_at: null | string;
    /**
     * Specifies whether all users of this site need to authenticate using two-factor authentication
     */
    require_2fa: boolean;
    /**
     * Specifies whether you want IPs to be tracked in the Project usages section
     */
    ip_tracking_enabled: boolean;
    /**
     * Specifies the theme to use in administrative area
     */
    theme: {
        primary_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        light_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        accent_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        dark_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        /**
         * The site logo
         */
        logo: string | null;
        [k: string]: unknown;
    };
    /**
     * Specifies default global settings
     */
    global_seo: {
        /**
         * Site name, used in social sharing
         */
        site_name?: string;
        fallback_seo?: {
            title: string;
            description: string;
            /**
             * The id of the image
             */
            image: null | string;
            /**
             * Determines how a Twitter link preview is shown
             */
            twitter_card?: null | ('summary' | 'summary_large_image');
            [k: string]: unknown;
        };
        /**
         * Title meta tag suffix
         */
        title_suffix?: null | string;
        /**
         * URL of facebook page
         */
        facebook_page_url?: null | string;
        /**
         * Twitter account associated to website
         */
        twitter_account?: null | string;
        [k: string]: unknown;
    } | null;
    account: AccountData;
    /**
     * The list item types for the site
     */
    item_types: ItemTypeData[];
    meta: SiteMeta;
};
export declare type SiteSelfTargetSchema = Site;
export declare type SiteUpdateJobSchema = Site;
export declare type SiteActivateImprovedTimezoneManagementJobSchema = Site;
/**
 * Meta attributes
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `definition` "meta".
 */
export declare type SiteMeta = {
    /**
     * Whether the Improved API Timezone Management option is active or not
     */
    improved_timezone_management: boolean;
};
/**
 * JSON API data
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `definition` "data".
 */
export declare type SiteData = {
    type: SiteType;
    id: SiteIdentity;
};
/**
 * JSON API attributes
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type SiteAttributes = {
    /**
     * Site name
     */
    name: string;
    /**
     * Administrative area custom domain
     */
    domain: string | null;
    /**
     * Google API Key to be used by the LatLon widget
     */
    google_maps_api_token: string | null;
    /**
     * Imgix host
     */
    imgix_host: string | null;
    /**
     * DatoCMS internal domain for the administrative area
     */
    internal_domain: string | null;
    /**
     * Available locales
     */
    locales: [string, ...string[]];
    /**
     * Site default timezone
     */
    timezone: string;
    /**
     * Whether the website needs to be indexed by search engines or not
     */
    no_index: boolean;
    /**
     * The upload id for the favicon
     */
    favicon: string | null;
    /**
     * Specifies the last time when a change of data occurred
     */
    last_data_change_at: null | string;
    /**
     * Specifies whether all users of this site need to authenticate using two-factor authentication
     */
    require_2fa: boolean;
    /**
     * Specifies whether you want IPs to be tracked in the Project usages section
     */
    ip_tracking_enabled: boolean;
    /**
     * Specifies the theme to use in administrative area
     */
    theme: {
        primary_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        light_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        accent_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        dark_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        /**
         * The site logo
         */
        logo: string | null;
        [k: string]: unknown;
    };
    /**
     * Specifies default global settings
     */
    global_seo: {
        /**
         * Site name, used in social sharing
         */
        site_name?: string;
        fallback_seo?: {
            title: string;
            description: string;
            /**
             * The id of the image
             */
            image: null | string;
            /**
             * Determines how a Twitter link preview is shown
             */
            twitter_card?: null | ('summary' | 'summary_large_image');
            [k: string]: unknown;
        };
        /**
         * Title meta tag suffix
         */
        title_suffix?: null | string;
        /**
         * URL of facebook page
         */
        facebook_page_url?: null | string;
        /**
         * Twitter account associated to website
         */
        twitter_account?: null | string;
        [k: string]: unknown;
    } | null;
};
/**
 * JSON API links
 *
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `definition` "relationships".
 */
export declare type SiteRelationships = {
    account: AccountData;
    /**
     * The list item types for the site
     */
    item_types: ItemTypeData[];
};
/**
 * This interface was referenced by `Site`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type SiteUpdateSchema = {
    id?: SiteIdentity;
    type?: SiteType;
    /**
     * Whether the website needs to be indexed by search engines or not
     */
    no_index?: boolean;
    /**
     * The upload id for the favicon
     */
    favicon?: string | null;
    /**
     * Specifies default global settings
     */
    global_seo?: {
        /**
         * Site name, used in social sharing
         */
        site_name?: string;
        fallback_seo?: {
            title: string;
            description: string;
            /**
             * The id of the image
             */
            image: null | string;
            /**
             * Determines how a Twitter link preview is shown
             */
            twitter_card?: null | ('summary' | 'summary_large_image');
            [k: string]: unknown;
        };
        /**
         * Title meta tag suffix
         */
        title_suffix?: null | string;
        /**
         * URL of facebook page
         */
        facebook_page_url?: null | string;
        /**
         * Twitter account associated to website
         */
        twitter_account?: null | string;
        [k: string]: unknown;
    } | null;
    /**
     * Site name
     */
    name?: string;
    /**
     * Specifies the theme to use in administrative area
     */
    theme?: {
        primary_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        light_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        accent_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        dark_color: {
            red: number;
            green: number;
            blue: number;
            alpha: number;
            [k: string]: unknown;
        };
        /**
         * The site logo
         */
        logo: string | null;
        [k: string]: unknown;
    };
    /**
     * Available locales
     */
    locales?: [string, ...string[]];
    /**
     * Site default timezone
     */
    timezone?: string;
    /**
     * Specifies whether all users of this site need to authenticate using two-factor authentication
     */
    require_2fa?: boolean;
    /**
     * Specifies whether you want IPs to be tracked in the Project usages section
     */
    ip_tracking_enabled?: boolean;
    sso_default_role?: RoleData;
    meta?: {
        /**
         * Whether the Improved API Timezone Management option is active or not
         */
        improved_timezone_management?: boolean;
    };
};
/**
 * Through workflows it is possible to set up a precise state machine able to bring a draft content up to the final publication (and beyond), through a series of intermediate, fully customizable approval steps.
 *
 * This interface was referenced by `DatoApi`'s JSON-Schema
 * via the `definition` "workflow".
 */
export declare type Workflow = {
    id: WorkflowIdentity;
    type: WorkflowType;
    /**
     * The name of the workflow
     */
    name: string;
    /**
     * The stages of the workflow
     */
    stages: [
        {
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        },
        ...{
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        }[]
    ];
};
export declare type WorkflowCreateTargetSchema = Workflow;
export declare type WorkflowUpdateTargetSchema = Workflow;
export declare type WorkflowSelfTargetSchema = Workflow;
/**
 * JSON API attributes
 *
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `definition` "attributes".
 */
export declare type WorkflowAttributes = {
    /**
     * The name of the workflow
     */
    name: string;
    /**
     * The stages of the workflow
     */
    stages: [
        {
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        },
        ...{
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        }[]
    ];
};
/**
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `create.schema` link.
 */
export declare type WorkflowCreateSchema = {
    id?: WorkflowIdentity;
    type?: WorkflowType;
    /**
     * The name of the workflow
     */
    name: string;
    /**
     * The stages of the workflow
     */
    stages: [
        {
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        },
        ...{
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        }[]
    ];
};
/**
 * This interface was referenced by `Workflow`'s JSON-Schema
 * via the `update.schema` link.
 */
export declare type WorkflowUpdateSchema = {
    id?: WorkflowIdentity;
    type?: WorkflowType;
    /**
     * The name of the workflow
     */
    name?: string;
    /**
     * The stages of the workflow
     */
    stages?: [
        {
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        },
        ...{
            /**
             * ID of the stage
             */
            id: string;
            /**
             * Name of the stage
             */
            name: string;
            /**
             * Description of the stage
             */
            description?: string | null;
            /**
             * Whether this is the initial stage or not
             */
            initial?: boolean;
        }[]
    ];
};
