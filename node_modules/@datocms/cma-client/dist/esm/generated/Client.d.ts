import { type LogLevel, request } from '@datocms/rest-client-utils';
import type { JobResult } from './ApiTypes';
import * as Resources from './resources';
export type RequestOptions = {
    method: 'GET' | 'PUT' | 'POST' | 'DELETE';
    url: string;
    queryParams?: Record<string, unknown>;
    body?: unknown;
    preCallStack?: string;
};
export type ClientConfigOptions = {
    /** The API token to use to perform requests */
    apiToken: string | null;
    /** The base URL of the server. Defaults to https://site-api.datocms.com */
    baseUrl?: string;
    /** The environment in which to perform every API request */
    environment?: string;
    /** Configure request timeout (in ms). When timeout is reached and `autoRetry` is active, a new request will be performed. Otherwise, a `TimeoutError` will be raised. Defaults to `30000` */
    requestTimeout?: number;
    /** Any extra header to add to every API request */
    extraHeaders?: Record<string, string>;
    /** Level of logging */
    logLevel?: LogLevel;
    /** Function to use to log. Defaults to `console.log` */
    logFn?: (message: string) => void;
    /** Whether to automatically retry failed requests (ie. timeout, rate-limiting, etc.), with a linear incremental backoff. Defaults to `true` */
    autoRetry?: boolean;
    /** If fetch() is not available in your environment, you can provide it */
    fetchFn?: Parameters<typeof request>[0]['fetchFn'];
};
export declare class Client {
    static readonly defaultBaseUrl = "https://site-api.datocms.com";
    roles: Resources.Role;
    users: Resources.User;
    ssoUsers: Resources.SsoUser;
    auditLogEvents: Resources.AuditLogEvent;
    menuItems: Resources.MenuItem;
    schemaMenuItems: Resources.SchemaMenuItem;
    uploadCollections: Resources.UploadCollection;
    itemTypes: Resources.ItemType;
    fields: Resources.Field;
    fieldsets: Resources.Fieldset;
    session: Resources.Session;
    accessTokens: Resources.AccessToken;
    plugins: Resources.Plugin;
    jobResults: Resources.JobResult;
    subscriptionLimits: Resources.SubscriptionLimit;
    subscriptionFeatures: Resources.SubscriptionFeature;
    buildEvents: Resources.BuildEvent;
    searchIndexEvents: Resources.SearchIndexEvent;
    items: Resources.Item;
    itemVersions: Resources.ItemVersion;
    uploads: Resources.Upload;
    uploadRequest: Resources.UploadRequest;
    uploadTracks: Resources.UploadTrack;
    scheduledPublication: Resources.ScheduledPublication;
    scheduledUnpublishing: Resources.ScheduledUnpublishing;
    searchResults: Resources.SearchResult;
    environments: Resources.Environment;
    maintenanceMode: Resources.MaintenanceMode;
    webhooks: Resources.Webhook;
    webhookCalls: Resources.WebhookCall;
    buildTriggers: Resources.BuildTrigger;
    searchIndexes: Resources.SearchIndex;
    itemTypeFilters: Resources.ItemTypeFilter;
    uploadFilters: Resources.UploadFilter;
    siteInvitations: Resources.SiteInvitation;
    editingSessions: Resources.EditingSession;
    ssoGroups: Resources.SsoGroup;
    ssoSettings: Resources.SsoSettings;
    emojiSuggestions: Resources.EmojiSuggestions;
    whiteLabelSettings: Resources.WhiteLabelSettings;
    publicInfo: Resources.PublicInfo;
    dailyUsages: Resources.DailyUsage;
    usageCounters: Resources.UsageCounter;
    uploadTags: Resources.UploadTag;
    uploadSmartTags: Resources.UploadSmartTag;
    site: Resources.Site;
    workflows: Resources.Workflow;
    config: ClientConfigOptions;
    jobResultsFetcher?: (jobId: string) => Promise<JobResult>;
    private cachedEventsChannelName;
    constructor(config: ClientConfigOptions);
    get baseUrl(): string;
    request<T>(options: RequestOptions): Promise<T>;
    eventsChannelName(): Promise<string>;
}
